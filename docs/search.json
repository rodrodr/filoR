[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "",
    "text": "La preparación representa el paso previo para convertir los textos en datos. En ese apartado, podrás encontrar cómo se han preparado los textos paso a paso."
  },
  {
    "objectID": "index.html#preparación-de-los-textos",
    "href": "index.html#preparación-de-los-textos",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "",
    "text": "La preparación representa el paso previo para convertir los textos en datos. En ese apartado, podrás encontrar cómo se han preparado los textos paso a paso."
  },
  {
    "objectID": "index.html#la-regenta",
    "href": "index.html#la-regenta",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "La Regenta",
    "text": "La Regenta\nEn el siguiente tópico, aplicamos un conjunto de técnicas de análisis y visualización de datos a la novela “La Regenta” de Leopoldo Alas Clarín.\nanalisis.html"
  },
  {
    "objectID": "index.html#tres-sombreros-de-copa",
    "href": "index.html#tres-sombreros-de-copa",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "Tres sombreros de copa",
    "text": "Tres sombreros de copa\nFinalmente, utilizamos la obra de teatro “Tres sombreros de copa” de Miguel Mihura como fuente para el empleo de técnicas de análisis de redes sociales en R a partir de textos literarios."
  },
  {
    "objectID": "prepa.html",
    "href": "prepa.html",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de datos aplicados a textos. Según las características de cada obra, podemos llevar a cabo un análisis de frecuencia de palabras, de sentimientos, emplear diccionarios (o glosarios) para identificar ciertos rasgos o atributos. También resulta posible jugar con su estructura, agregando los datos por párrafo, capítulo, personaje o cualquier otra características que lo permita.\nPara el presente curso, hemos seleccionado dos textos literarios: una novela y una obra de teatro. La novela es “La Regenta”, de Leopoldo Alas “Clarín”. La obra de teatro es “Tres sombreros de copa”, de Miguel Mihura. Ambas obras son clásicos de la literatura española y permiten comparar los resultados de los análisis de textos literarios. No obstante, nos interesan en particular por sus diferencias estructurales y cómo nos permiten realizar distintos tipos de análisis.\nAunque ambas puedan ser objeto de la mayor parte de los análisis que introduciremos aquí, cada una de ellas nos permitirá aplicar distintas técnicas de modo más fructífero. Por ejemplo, en “La Regenta” nos interesará explorar la estructura de los capítulos, los temas que aparecen, sus principales personajes, la frecuencia de palabras y la red de palabras. En el caso de “Tres sombreros de copa”, nos interesará explorar la red de diálogos y medir las diferentes formas de centralidad o influencia de los personajes en la trama."
  },
  {
    "objectID": "prepa.html#introducción",
    "href": "prepa.html#introducción",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de datos aplicados a textos. Según las características de cada obra, podemos llevar a cabo un análisis de frecuencia de palabras, de sentimientos, emplear diccionarios (o glosarios) para identificar ciertos rasgos o atributos. También resulta posible jugar con su estructura, agregando los datos por párrafo, capítulo, personaje o cualquier otra características que lo permita.\nPara el presente curso, hemos seleccionado dos textos literarios: una novela y una obra de teatro. La novela es “La Regenta”, de Leopoldo Alas “Clarín”. La obra de teatro es “Tres sombreros de copa”, de Miguel Mihura. Ambas obras son clásicos de la literatura española y permiten comparar los resultados de los análisis de textos literarios. No obstante, nos interesan en particular por sus diferencias estructurales y cómo nos permiten realizar distintos tipos de análisis.\nAunque ambas puedan ser objeto de la mayor parte de los análisis que introduciremos aquí, cada una de ellas nos permitirá aplicar distintas técnicas de modo más fructífero. Por ejemplo, en “La Regenta” nos interesará explorar la estructura de los capítulos, los temas que aparecen, sus principales personajes, la frecuencia de palabras y la red de palabras. En el caso de “Tres sombreros de copa”, nos interesará explorar la red de diálogos y medir las diferentes formas de centralidad o influencia de los personajes en la trama."
  },
  {
    "objectID": "prepa.html#novela",
    "href": "prepa.html#novela",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "Novela",
    "text": "Novela\nResulta muy sencillo descargar la novela “La Regenta”. Podemos emplear el paquete gutenbergr para descargar el texto directamente en R y trabajar con él. Solo tenemos que añadir un paso más al trabajo, que es convertir la codificación de caracteres a “latin1” para evitar problemas con las tildes.\n\n# Abre la librería gutenbergr\n# para bajar el texto\nlibrary(gutenbergr)\n\n# Baja el texto de \"La Regenta\"\n# cuyo id es igual 17073\nre &lt;- gutenberg_download(gutenberg_id = 17073, \n                         verbose = FALSE)\n\n# Cambia la codificación de caracteres a\n# a latin1 para evitar problemas con las tildes\nEncoding(re$text) &lt;- \"latin1\"\n\n# Convierte el texto en un solo string\nre &lt;- paste0(re$text, \n             collapse = \"\\n\")\n\nCon ese sencillo primer paso, ya tenemos la novela en nuestro ordenador. No obstante, hacen falta algunos pasos adicionales para convertir el texto en una base de datos que podamos emplear para hacer comparaciones, análisis de redes de palabras, etc.\nEl siguiente paso consiste en eliminar los saltos de línea y recuperar la estructura de los párrafos. Para ello, empleamos una expresión regular que nos permita identificar los párrafos y corregir los saltos de línea al final de cada frase.\n\n# Carga el paquete stringi\n# que permite trabajar con expresiones regulares\n# y otras tareas de manipulación\n# de textos\nlibrary(stringi)\n\n# Corrige los párrafos para que no tengan\n# un salto de línea al final de cada frase\nrx &lt;- stri_replace_all_regex(\n            re,\n            \"(\\\\S|\\\\p{L})(\\n)(\\\\S{1}|\\\\p{L})\",\"$1 $3\")\n\nPara entender lo que hemos hecho, explicaremos la gramática de la expresión regular empleada:\n\n(\\\\S|\\\\p{L}): busca uno o más caracteres que no sean espacios en blanco (\\S) o (|) una letra con acentuación latina (\\p{L}).\n(\\n): busca un salto de línea.\n(\\\\S{1}|\\\\p{L}): busca un único carácter que no sea un espacio en blanco (\\S{1}) o (|) una letra con acentuación latina (\\p{L}).\n\ny los reemplaza por:\n\n$1 $3: por el primer carácter encontrado ($1), un espacio y el último carácter encontrado ($3).\n\nDe ese modo:\n“El poeta es un fingidor.”\n“Finge tan completamente”\n“que llega a fingir que es dolor”\n“el dolor que de verdad siente.”\nse convierte en:\n“El poeta es un fingidor. Finge tan completamente que llega a fingir que es dolor el dolor que de verdad siente.”\nDe ese modo, el R lo hace para TODOS los párrafos a la vez y nos ahora mucho trabajo de preparación de cualquier texto.\nUna vez corregidos los párrafos, podemos convertir el texto en un vector de líneas para poder trabajar con él.\n\n# Carga el paquete readr, que permite\n# convertir textos en vectores\nlibrary(readr)\n\n# Vuelve a seleccionar los párrafos\nre &lt;- read_lines(rx)\n\nEl resultado es un vector de caracteres llamado re con 12.164 elementos. Cada elemento corresponde o bien a un párrafo o bien a un salto de línea que marca la separación entre dos párrafos.\nCon esa información, nos interesa asociar cada párrafo a la estructura formal de la novela. En el caso de “La Regenta”, la novela está dividida en un prólogo, dos tomos y 30 capítulos, siendo los quince primeros pertenecientes al primer tomo y los quince restantes al segundo.\nPara llevar a cabo dicha tarea, debemos identificar los elementos que marcan el inicio de cada parte de la novela. En este caso, el prólogo, los tomos y los capítulos. El prólogo y los tomos son fácilmente identificables por su título. Basta con buscar en qué líneas aparecen las palabras “Prólogo” y “Tomo” para identificarlos.\nLos capítulos, por otra parte, exigen un poco más de trabajo. Se enumeran con números romanos precedidos y seguidos de dos guiones. Por ejemplo, “–I–” indica el punto en el que empieza primer capítulo. “–II–” encuentra el elemento que da inicio al segundo y así sucesivamente. En nuestro ejemplo, el primer capítulo empieza en la línea 59 y el segundo en la 311. Por lo tanto, sé que todos los párrafos comprendidos entre 59 y 310 corresponden al primer capítulo.\n\n# Encuentra los índices del prólogo, de\n# los tomos y los capítulos\npro &lt;- grep(\"Prólogo\",re) # prólogo\ntm &lt;- c(grep(\"Tomo\",re), \n        grep(\"TOMO\",re)) # tomos - índice\ncap &lt;- which(stri_detect_regex(re, \n                            \"^(--)([A-Z]+)(--)$\")==TRUE) # capítulos\n\n\n# Crea vectores que obtienen\n# los títulos de los tomos y los capítulos\ntx &lt;- re[tm] # tomos - textos\ncx &lt;- re[cap] # capítulos - textos\n\nCon los índices, puedo repetir cada nombre de tomo, capítulo, prólogo, etc. en función de cuántos párrafos tenga cada uno. De ese modo, puedo asociar cada párrafo a su correspondiente título, tomo o capítulo:\n\n# Genera un vector que identifica qué líneas\n# pertenecen al título y al prólogo\nti &lt;- rep(\"Título\", \n          length(1:(pro-1)))\n\npro &lt;- rep(\"Prólogo\", \n           length(pro:(tm[1]-1)))\n\n# Genera el vector ta que identifica qué líneas\n# pertenecen a cada tomo\nta &lt;- vector()\n\nfor(i in 1:(length(tm)-1)){\n  \n  ta &lt;- c(ta, \n          rep(tx[i], \n              length((tm[i]):(tm[i+1]-1))))\n  \n}\n\nta &lt;- c(ta, \n        rep(tx[length(tx)],\n            length((tm[length(tm)]):length(re))))\n\n\n# Genera el vector ca que identifica qué líneas\n# pertenecen a cada capítulo\nca &lt;- vector()\n\nfor(i in 1:(length(cap)-1)){\n  \n  ca &lt;- c(ca, \n          rep(cx[i], \n              length((cap[i]):(cap[i+1]-1))))\n  \n}\n\nca &lt;- c(ca, \n        rep(cx[length(cx)], \n            length((cap[length(cap)]):length(re))))\n\nFinalmente, empleo todos los vectores generados para crear una base de datos que refleje de modo correcto la parte, el capítulo y el texto de cada párrafo:\n\n# Crea un data frame con los textos, la \n# identificación, de la parte y del capítulo\npt &lt;- c(ti,pro,ta)\ncp &lt;- c(rep(\"Previa\", 58),\n        ca)\ndx &lt;- data.frame(parte = pt, \n                 capitulo= cp, \n                 texto = re)\n\nAhora, nos toca transformar la numeración de los capítulos para poder mantener un orden secuencial. Además, nos interesa saber el número del párrafo en cada capítulo, para poder mencionar exactamente dónde se encuentra una referencia exacta en el texto. También queremos eliminar la información que no nos interesa, como los espacios en blanco entre párrafos:\n\n# Elimina los guiones de al identificación de\n# cada capítulo\ndx$capitulo &lt;- gsub(\"--\", \"\", dx$capitulo)\n\n# Convierte los textos de identificación de los\n# capítulos en números romanos y luego los\n# convierte en numérico\ndx$roman &lt;- as.roman(dx$capitulo)\ndx$roman &lt;- as.numeric(dx$roman)\n\n# Asigna los valores numéricos a los capítulos\ndx$capitulo[!is.na(dx$roman)] &lt;- dx$roman[!is.na(dx$roman)]\ndx$capitulo[is.na(dx$roman)] &lt;- dx$parte[is.na(dx$roman)]\n\n# Añade un 0 (cero) para los capítulos menores a\n# 10.\ndx$capitulo[nchar(dx$capitulo) == 1] &lt;- paste0(\"0\",\n    dx$capitulo[nchar(dx$capitulo) == 1])\n\n# Añade 001 y 002 para el título y el prólogo.\n# De ese modo, quedan los primeros una vez se\n# ordene la base de datos.\ndx$capitulo[dx$capitulo == \"Título\"] &lt;- \"001 - Título\"\ndx$capitulo[dx$capitulo == \"Prólogo\"] &lt;- \"002 - Prólogo\"\n\n# Elimina la información que no interesa\ndx &lt;- dx[dx$parte != dx$texto, ]\ndx$roman &lt;- NULL\ndx &lt;- dx[dx$texto != \"\", ]\n\n# Añade un número de párrafo a cada párrafo de\n# cada capítulo. Así que siempre se reinicia en\n# cuenteo a cada nuevo capítulo.\nlibrary(dplyr)\ndx &lt;- dx |&gt;\n    group_by(capitulo) |&gt;\n    mutate(parrafo = row_number())\n\n# Elimina los espacios en blanco al principio y\n# al final del texto\ndx$texto &lt;- trimws(dx$texto)\n\n# Selecciona solo las variables.de interés\ndx &lt;- dx[, c(\"parte\", \"capitulo\", \"parrafo\", \"texto\")]\n\n\n# Visualiza los resultados\nlibrary(reactable)\nreactable(dx, resizable = T, wrap = F)\n\n\n\n\n\n\nEl paso siguiente consiste en crear una versión distinta del mismo texto. Pero ahora, la novela será dividida de forma que cada observación en la base de datos corresponderá a un capítulo completo:\n\n# Genera una base de datos agregada por capítulo\n# (y no por párrafo, como la anterior)\ndc &lt;- aggregate(list(texto = dx$texto), by = list(parte = dx$parte,\n    capitulo = dx$capitulo), FUN = paste, collapse = \"\\n\\n\")\n\n# Visualiza los resultados\nreactable(dc, resizable = T, wrap = F)\n\n\n\n\n\n\nFinalmente, estandarizamos los nombres de las dos bases de datos y, a continuación, las guardamos en un archivo de R que será empleado en los análisis:\n\n# Estandariza los nombres de las\n# bases de datos\nregp &lt;- dx\nregc &lt;- dc\n\n# Guarda los resultados\nsave(regp, regc, file=\"textos/Regenta.RData\")"
  },
  {
    "objectID": "prepa.html#obra-de-teatro",
    "href": "prepa.html#obra-de-teatro",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "Obra de teatro",
    "text": "Obra de teatro\n\nEstructura de la base de datos\nEn el caso de una obra de teatro, la estructura de la base de datos es diferente. En lugar de partes y capítulos, tenemos actos y escenas. Además, en lugar de párrafos, tenemos diálogos. Existen marcadores claros que nos permiten identificar cada una de las partes.\nPor su misma estructura, además, las obras de teatro son excelente material para la realización de determinados análisis como el análisis de redes sociales (SNA, en su sigla en inglés). También permiten otros tipos de agregación, como, por ejemplo, por personaje o por acto. De ese modo, es posible analizar las diferencias en términos de lenguaje, vocabulario o temas. Aunque se pueda hacer algo parecido con una novela, el proceso de identificación del diálogo de cada personaje resulta significativamente más laborioso cuando comparado con una pieza teatral.\nComo en el caso de la novela, obtendremos dos bases de datos. La primera contendrá los datos del acto, personaje que habla, personaje a quien destina su habla, el orden del diálogo en la obra y el texto del diálogo.\nLa segunda base de datos estará conformada por una lista de vínculos entre pares de personajes y el número de veces que se comunican. A partir de ese dato, podemos crear diferentes análisis y visualizaciones de la red, así como medir la importancia relativa de cada personaje en la obra.\nPara ello, emplearemos la obra “Tres sombreros de copa” de Miguel Mihura. Se trata de una pieza en tres actos con 18 personajes. No presenta una estructura compleja, lo que facilita el tratamiento de los datos.\n\n\nDe diálogos a datos\nLa obra de Mihura …\n\n# Carga los paquetes necesarios para el\n# tratamiento de los textos\nlibrary(pdftools)  # Lee el pdf original de la obra\nlibrary(readr)  # Lee las líneas del texto \nlibrary(stringi)  # Funciones de manipulación de texto\n\n# Lee el pdf de la obra de Mihura\npd &lt;- pdf_text(\"https://www.edu.xunta.gal/centros/cpilorenzobaleiron/system/files/u2/mihura__miguel_-_tres_sombreros_de_copa.pdf\")\n\n\n\n# Elimina los espacios en blanco múltiples entre\n# palabras\npx &lt;- read_lines(pd)\npx &lt;- trimws(px)\npx &lt;- gsub(\"\\\\s+\", \" \", px, perl = T)\n\n# Elimina las cabeceras de las páginas y los\n# números de página del PDF\nnn &lt;- which(px %in% c(\"3 sombreros de copa Miguel Mihura\"))\npd &lt;- px[-c(nn - 1, nn)]\n\n# Elimina el número de la última página\npd &lt;- pd[-length(pd)]"
  },
  {
    "objectID": "regenta.html",
    "href": "regenta.html",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos.\nDos tipos de texto. De un lado, una novela. De otro, una obra de teatro. Abren la posibilidad de comparar los resultados de los análisis de textos literarios."
  },
  {
    "objectID": "regenta.html#introducción",
    "href": "regenta.html#introducción",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos.\nDos tipos de texto. De un lado, una novela. De otro, una obra de teatro. Abren la posibilidad de comparar los resultados de los análisis de textos literarios."
  },
  {
    "objectID": "regenta.html#análisis-de-la-novela-la-regenta",
    "href": "regenta.html#análisis-de-la-novela-la-regenta",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "Análisis de la novela “La Regenta”",
    "text": "Análisis de la novela “La Regenta”\nAbrimos los datos\n\n# carga los datos de \"La Regenta\"\nload(\"../textos/Regenta.RData\")\n\nHacemos un análisis sumario de los capítulos\n\n# carga el paquete quanteda para \n# algunos análisis\nlibrary(quanteda)\n\n# convierte en un documento corpus\ncp &lt;- corpus(regc, text_field = \"texto\")\n\n# define los capítulos como nombre\n# de los documentos\ndocnames(cp) &lt;- regc$capitulo\n\n# muestra estadísticas básicas de\n# cada capítulo\nsummary(cp)\n\nCorpus consisting of 32 documents, showing 32 documents:\n\n          Text Types Tokens Sentences   parte      capitulo\n  001 - Título    16     16         1  Título  001 - Título\n 002 - Prólogo  1661   4649       101 Prólogo 002 - Prólogo\n            01  3753  14662       466  Tomo I            01\n            02  2236   8029       298  Tomo I            02\n            03  2194   8395       384  Tomo I            03\n            04  2448   9121       360  Tomo I            04\n            05  3104  13640       542  Tomo I            05\n            06  2312   8171       347  Tomo I            06\n            07  2194   9012       391  Tomo I            07\n            08  3178  13095       581  Tomo I            08\n            09  2832  10992       492  Tomo I            09\n            10  2096   8184       390  Tomo I            10\n            11  3026  13356       529  Tomo I            11\n            12  4169  18985       717  Tomo I            12\n            13  3611  17074       541  Tomo I            13\n            14  1980   8172       345  Tomo I            14\n            15  2869  13484       531  Tomo I            15\n            16  4022  17978       543 Tomo II            16\n            17  2190   9804       332 Tomo II            17\n            18  2793  10446       311 Tomo II            18\n            19  2947  12333       407 Tomo II            19\n            20  3753  16462       626 Tomo II            20\n            21  3681  16554       676 Tomo II            21\n            22  3256  14615       522 Tomo II            22\n            23  2087   8302       308 Tomo II            23\n            24  2031   8248       317 Tomo II            24\n            25  2343  10096       476 Tomo II            25\n            26  2812  12811       534 Tomo II            26\n            27  3122  14099       642 Tomo II            27\n            28  2889  13290       491 Tomo II            28\n            29  3532  18228       716 Tomo II            29\n            30  3724  21083       843 Tomo II            30\n\n\nHacemos un análisis de frecuencia de palabras\n\n# convierte en una matriz de términos\ndtm &lt;- dfm(tokens(cp, remove_punct = TRUE, \n                  remove_numbers = TRUE, \n                  remove_symbols = TRUE), \n           tolower = TRUE)\n\ndtm &lt;- dfm_remove(dtm, c(stopwords(\"es\"),\"si\"))\n\n# muestra las 50 palabras más frecuentes\ntopfeatures(dtm, 50)\n\n      don       ana     usted magistral   aquella     aquel    álvaro    víctor \n     1791       897       822       769       761       733       490       489 \n     casa   regenta     señor   vetusta      allí       ser   después      doña \n      482       468       458       455       450       437       417       414 \n    decía       vez     mesía     podía     ahora      bien    fermín       así \n      414       392       373       369       364       353       350       347 \n     ojos       dos       iba   siempre    quería       tan     menos      dijo \n      347       334       333       332       328       327       327       326 \n     vida     mismo    hombre      dios     veces quintanar     mundo     mujer \n      324       320       315       310       307       305       290       286 \n   tiempo     todas      alma       ver     sabía       día   parecía      amor \n      283       282       281       280       279       271       267       267 \n  aquello     decir \n      265       259 \n\n\ndiccionario\n\ndic &lt;- dictionary(\n  list(\n    familia=c(\"padre\", \"madre\", \"hijo\", \"hija\", \"hermano\", \"hermana\"),\n    sociedad=c(\"vetustense\",\"señor\",\"puebl\",\"ciudad\",\"conversa\",\"amig\"),\n    iglesia=c(\"cura\",\"obispo\",\"sacerdo\",\"confesión\",\"religi\",\"canónig\",\"capilla\"),\n    economia=c(\"dinero\",\"deuda\",\"negoci\",\"trabaj\",\"fortuna\",\"rico\",\"rica\"),\n    sentimientos=c(\"culpa\",\"alegr\",\"amor\",\"remordimiento\",\"ridículo\",\"vergüenza\",\"triste\"),\n    misticismo=c(\"Fermín de Pas\",\"Fermín\",\"\\\\bde Pas\\\\b\", \"magistral\", \"espirit\",\"dios\"),\n    adulterio=c(\"Álvaro Mesía\",\"Álvaro\",\"Mesía\",\"Presidente del Casino\", \"marido\", \"placer\", \"pasión\", \"amante\",\"amorío\"),\n    espacio=c(\"casino\",\"catedral\",\"vivero\",\"casa\",\"espolón\",\"teatro\"),\n    tiempo=c(\"otoño\",\"verano\",\"invierno\",\"primavera\",\"semana santa\",\"navidad\")\n  )\n)\n    \nlibrary(tenet)\n    \ntagCorpus(cp, dic, reshape.to = \"sentence\")\n\n\n\n\n\n\n\ndicf &lt;- dictionary(\n  list(\n    familia=c(\"padre\", \"madre\", \"hijo\", \"hija\", \"hermano\", \"hermana\"),\n    sociedad=c(\"vetustense\",\"señor\",\"puebl\",\"ciudad\",\"conversa\",\"amig\")\n))\n\n\nplotLexDiv(cp, dicf, title =\"La Regenta\", subtitle = \"Familia e iglesia en la novela\", palette = pal$cat.awtools.spalette.6[1:2])\n\n\n\n\n\nxy &lt;- countKeywords(cp, \n                    dic, \n                    rel.freq = F, \n                    quietly = TRUE)\n\n# Elimina los términos no encontrados\nxy &lt;- xy[xy$frequency&gt;0,]\n\nxy$groups &lt;- NULL\n\nforceDirectedTree(xy,value_col = \"frequency\",\n                  palette = pal$cat.awtools.bpalette.16, \n                  max.radius = 50, \n                  height = 500)\n\n\n\n\n\nlo mismo se puede ver así:\n\nplotVoronoiTree(data = xy,\n                value_col = \"frequency\")\n\n\n\n\n\ndd\n\ndich &lt;- dictionary(\n  list(\n    hombres=\n      list(\n           Alvaro=c(\"Álvaro Mesía\",\n                    \"Álvaro\",\n                    \"Mesía\",\n                    \"presidente del casino\"),\n           Saturnino=c(\"Saturnino Bermúdez\",\n                       \"Saturnino\",\n                       \"Bermúdez\",\n                       \"Saturno\",\n                       \"Saturnillo\"),\n           Fermin=c(\"Magistral\",\n                    \"Provisor\",\n                    \"Fermín\",\n                    \"De Pas\",\n                    \"Fermín de Pas\",\n                    \"Magistral\"),\n           Victor=c(\"Víctor\",\n                    \"Víctor Quintanar\",\n                    \"Quintanar\"),\n           Otros=c(\"Custodio\",\n                   \"Frígilis\",\n                   \"Anacleto\",\n                   \"Carlos\",\n                   \"Orgaz\",\n                   \"Bismark\",\n                   \"Celedonio\",\n                   \"monaguillo\",\n                   \"Pedro\",\n                   \"Palomo\",\n                   \"Cayetano\",\n                   \"Cayetano Ripamilán\",\n                   \"Ripamilán\",\n                   \"Cenceño\",\n                   \"Pompeyo\",\n                   \"Pompeyo Guimarán\",\n                   \"Guimarán\",\n                   \"Paco\",\n                   \"Paquito\",\n                   \"don Santos\")\n           ),\n    mujeres=\n      list(\n        Ana=c(\"Ana\",\n              \"Anita\",\n              \"Regenta\"),\n        Obdulia=c(\"Obdulia\",\n                  \"Obdulia Fandiño\",\n                  \"Fandiño\",\n                  \"Obdulita\"),\n        Otras=c(\"Visitación\",\n                \"Petra\",\n                \"Camila\",\n                \"doña Anuncia\",\n                \"Anuncita\",\n                \"Águeda\",\n                \"doña Paula\",\n                \"marquesa\",\n                \"doña Petronila\")\n    )\n  )\n)\n\n\n\n\nxp &lt;- countKeywords(cp, \n                    dich, \n                    rel.freq = F, \n                    group.var = \"capitulo\",\n                    quietly = TRUE)\n\n# Agrega los resultados por los dos niveles\n# de código del diccionario\nxx &lt;- aggregate(list(frequency=xp$frequency), \n                by=list(groups=xp$groups, \n                        level1=xp$level2), \n                sum, na.rm=T)\n\n# Elimina los términos no encontrados\n# en el corpus\nxx &lt;- xx[xx$frequency&gt;0,]\n\n# Ordena por capítulo\nxx &lt;- xx[order(xx$groups),]\n\nplotSankey(xx, \n           from = \"level1\", \n           to=\"groups\", \n           value = \"frequency\", \n           opacity = 0.05)\n\n\n\n\n\ndddd\n\n# Reorganiza el corpus según\n# sentencias o frases\ncs &lt;- corpus_reshape(cp, \"sentences\")\n\n# Calcula la frecuencia en la\n# que dos codigos del mismo \n# diccionario aparecen juntos\n# en cada frase\nd1 &lt;- matchCodes(cs, \n                dic, \n                level = 1, \n                quietly=TRUE)\n\n# Ordena los resultados de mayor a menor\nd1 &lt;- d1[order(d1$value, decreasing = T),]\n\n\nplotChord(d1, \n          from = \"term1\", \n          to =\"term2\", \n          value= \"value\")\n\n\n\n\n\nAhora con los personajes\n\n# Reorganiza el corpus según\n# sentencias o frases\ncs &lt;- corpus_reshape(cp, \"sentences\")\n\n# Calcula la frecuencia en la\n# que dos codigos del mismo \n# diccionario aparecen juntos\n# en cada frase\nd1 &lt;- matchCodes(cs, \n                dich, \n                level = 2, \n                quietly=TRUE)\n\n# Ordena los resultados de mayor a menor\nd1 &lt;- d1[order(d1$value, decreasing = T),]\n\n\nplotChord(d1, \n          from = \"term1\", \n          to =\"term2\", \n          value= \"value\", elementId = \"chord2\")\n\n\n\n\n\naaa"
  },
  {
    "objectID": "sombreros.html",
    "href": "sombreros.html",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos."
  },
  {
    "objectID": "sombreros.html#introducción",
    "href": "sombreros.html#introducción",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos."
  },
  {
    "objectID": "sombreros.html#redes-de-diálogo-en-tres-sombreros-de-copa",
    "href": "sombreros.html#redes-de-diálogo-en-tres-sombreros-de-copa",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "Redes de diálogo en “Tres sombreros de copa”",
    "text": "Redes de diálogo en “Tres sombreros de copa”\nAbrimos los datos\n\n# carga los datos de \"La Regenta\"\nload(\"../textos/Regenta.RData\")\n\nHacemos un análisis sumario de los capítulos\naaa"
  },
  {
    "objectID": "prepa.html#la-regenta-párrafos-y-capítulos",
    "href": "prepa.html#la-regenta-párrafos-y-capítulos",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "“La Regenta”: párrafos y capítulos",
    "text": "“La Regenta”: párrafos y capítulos\n\nEstructura de la base de datos\nLa novela “La Regenta” es una obra de Leopoldo Alas “Clarín” publicada en 1884. Es una de las novelas más importantes de la literatura española y, en particular, de la novela realista del siglo XIX. La novela se compone de 30 capítulos, divididos en dos tomos de 15 capítulos cada uno.\nEl objetivo de este apartado es preparar el texto de “La Regenta” para su análisis empleando herramientas y técnicas estadísticas. De modo concreto, nos interesa organizar el texto en dos bases de datos. La primera organizada por párrafos y la segunda por capítulos. Cada una de ellas permitirá la aplicación de análisis con distinto nivel de detalle.\nLlamaremos aquí “base de datos” una tabla de datos con N filas y N columnas. Cada fila corresponderá a un párrafo o capítulo y cada columna a una variable que nos interese analizar. Tendremos, por lo tanto, dos unidades de agregación y sus correspondientes atributos: parte (título, prólogo o tomo), capítulo, párrafo (en su caso) y texto.\n\n\nMétodo de conversión de texto a datos\nResulta muy sencillo descargar la novela “La Regenta”. Podemos emplear el paquete gutenbergr para descargar el texto directamente en R y trabajar con él. Solo tenemos que añadir un paso más al trabajo, que es convertir la codificación de caracteres a “latin1” para evitar problemas con las tildes.\n\n# Abre la librería gutenbergr\n# para bajar el texto\nlibrary(gutenbergr)\n\n# Baja el texto de \"La Regenta\"\n# cuyo id es igual 17073\nre &lt;- gutenberg_download(gutenberg_id = 17073, \n                         verbose = FALSE)\n\n# Cambia la codificación de caracteres a\n# a latin1 para evitar problemas con las tildes\nEncoding(re$text) &lt;- \"latin1\"\n\n# Convierte el texto en un solo string\nre &lt;- paste0(re$text, \n             collapse = \"\\n\")\n\nCon ese sencillo primer paso, ya tenemos la novela en nuestro ordenador. No obstante, hacen falta algunos pasos adicionales para convertir el texto en una base de datos que podamos emplear para hacer comparaciones, análisis de redes de palabras, etc.\nEl siguiente paso consiste en eliminar los saltos de línea y recuperar la estructura de los párrafos. Para ello, empleamos una expresión regular que nos permita identificar los párrafos y corregir los saltos de línea al final de cada frase.\n\n# Carga el paquete stringi\n# que permite trabajar con expresiones regulares\n# y otras tareas de manipulación\n# de textos\nlibrary(stringi)\n\n# Corrige los párrafos para que no tengan\n# un salto de línea al final de cada frase\nrx &lt;- stri_replace_all_regex(\n            re,\n            \"(\\\\S|\\\\p{L})(\\n)(\\\\S{1}|\\\\p{L})\",\"$1 $3\")\n\nPara entender lo que hemos hecho, explicaremos la gramática de la expresión regular empleada:\n\n(\\\\S|\\\\p{L}): busca uno o más caracteres que no sean espacios en blanco (\\S) o (|) una letra con acentuación latina (\\p{L}).\n(\\n): busca un salto de línea.\n(\\\\S{1}|\\\\p{L}): busca un único carácter que no sea un espacio en blanco (\\S{1}) o (|) una letra con acentuación latina (\\p{L}).\n\ny los reemplaza por:\n\n$1 $3: por el primer carácter encontrado ($1), un espacio y el último carácter encontrado ($3).\n\nDe ese modo:\n“El poeta es un fingidor.”\n“Finge tan completamente”\n“que llega a fingir que es dolor”\n“el dolor que de verdad siente.”\nse convierte en:\n“El poeta es un fingidor. Finge tan completamente que llega a fingir que es dolor el dolor que de verdad siente.”\nDe ese modo, el R lo hace para TODOS los párrafos a la vez y nos ahora mucho trabajo de preparación de cualquier texto.\nUna vez corregidos los párrafos, podemos convertir el texto en un vector de líneas para poder trabajar con él.\n\n# Carga el paquete readr, que permite\n# convertir textos en vectores\nlibrary(readr)\n\n# Vuelve a seleccionar los párrafos\nre &lt;- read_lines(rx)\n\nEl resultado es un vector de caracteres llamado re con 12.164 elementos. Cada elemento corresponde o bien a un párrafo o bien a un salto de línea que marca la separación entre dos párrafos.\nCon esa información, nos interesa asociar cada párrafo a la estructura formal de la novela. En el caso de “La Regenta”, la novela está dividida en un prólogo, dos tomos y 30 capítulos, siendo los quince primeros pertenecientes al primer tomo y los quince restantes al segundo.\nPara llevar a cabo dicha tarea, debemos identificar los elementos que marcan el inicio de cada parte de la novela. En este caso, el prólogo, los tomos y los capítulos. El prólogo y los tomos son fácilmente identificables por su título. Basta con buscar en qué líneas aparecen las palabras “Prólogo” y “Tomo” para identificarlos.\nLos capítulos, por otra parte, exigen un poco más de trabajo. Se enumeran con números romanos precedidos y seguidos de dos guiones. Por ejemplo, “–I–” indica el punto en el que empieza primer capítulo. “–II–” encuentra el elemento que da inicio al segundo y así sucesivamente. En nuestro ejemplo, el primer capítulo empieza en la línea 59 y el segundo en la 311. Por lo tanto, sé que todos los párrafos comprendidos entre 59 y 310 corresponden al primer capítulo.\n\n# Encuentra los índices del prólogo, de\n# los tomos y los capítulos\npro &lt;- grep(\"Prólogo\",re) # prólogo\ntm &lt;- c(grep(\"Tomo\",re), \n        grep(\"TOMO\",re)) # tomos - índice\ncap &lt;- which(stri_detect_regex(re, \n                            \"^(--)([A-Z]+)(--)$\")==TRUE) # capítulos\n\n\n# Crea vectores que obtienen\n# los títulos de los tomos y los capítulos\ntx &lt;- re[tm] # tomos - textos\ncx &lt;- re[cap] # capítulos - textos\n\nCon los índices, puedo repetir cada nombre de tomo, capítulo, prólogo, etc. en función de cuántos párrafos tenga cada uno. De ese modo, puedo asociar cada párrafo a su correspondiente título, tomo o capítulo:\n\n# Genera un vector que identifica qué líneas\n# pertenecen al título y al prólogo\nti &lt;- rep(\"Título\", \n          length(1:(pro-1)))\n\npro &lt;- rep(\"Prólogo\", \n           length(pro:(tm[1]-1)))\n\n# Genera el vector ta que identifica qué líneas\n# pertenecen a cada tomo\nta &lt;- vector()\n\nfor(i in 1:(length(tm)-1)){\n  \n  ta &lt;- c(ta, \n          rep(tx[i], \n              length((tm[i]):(tm[i+1]-1))))\n  \n}\n\nta &lt;- c(ta, \n        rep(tx[length(tx)],\n            length((tm[length(tm)]):length(re))))\n\n\n# Genera el vector ca que identifica qué líneas\n# pertenecen a cada capítulo\nca &lt;- vector()\n\nfor(i in 1:(length(cap)-1)){\n  \n  ca &lt;- c(ca, \n          rep(cx[i], \n              length((cap[i]):(cap[i+1]-1))))\n  \n}\n\nca &lt;- c(ca, \n        rep(cx[length(cx)], \n            length((cap[length(cap)]):length(re))))\n\nFinalmente, empleo todos los vectores generados para crear una base de datos que refleje de modo correcto la parte, el capítulo y el texto de cada párrafo:\n\n# Crea un data frame con los textos, la \n# identificación, de la parte y del capítulo\npt &lt;- c(ti,pro,ta)\ncp &lt;- c(rep(\"Previa\", 58),\n        ca)\ndx &lt;- data.frame(parte = pt, \n                 capitulo= cp, \n                 texto = re)\n\nAhora, nos toca transformar la numeración de los capítulos para poder mantener un orden secuencial. Además, nos interesa saber el número del párrafo en cada capítulo, para poder mencionar exactamente dónde se encuentra una referencia exacta en el texto. También queremos eliminar la información que no nos interesa, como los espacios en blanco entre párrafos:\n\n# Elimina los guiones de al identificación de\n# cada capítulo\ndx$capitulo &lt;- gsub(\"--\", \"\", dx$capitulo)\n\n# Convierte los textos de identificación de los\n# capítulos en números romanos y luego los\n# convierte en numérico\ndx$roman &lt;- as.roman(dx$capitulo)\ndx$roman &lt;- as.numeric(dx$roman)\n\n# Asigna los valores numéricos a los capítulos\ndx$capitulo[!is.na(dx$roman)] &lt;- dx$roman[!is.na(dx$roman)]\ndx$capitulo[is.na(dx$roman)] &lt;- dx$parte[is.na(dx$roman)]\n\n# Añade un 0 (cero) para los capítulos menores a\n# 10.\ndx$capitulo[nchar(dx$capitulo) == 1] &lt;- paste0(\"0\",\n    dx$capitulo[nchar(dx$capitulo) == 1])\n\n# Añade 001 y 002 para el título y el prólogo.\n# De ese modo, quedan los primeros una vez se\n# ordene la base de datos.\ndx$capitulo[dx$capitulo == \"Título\"] &lt;- \"001 - Título\"\ndx$capitulo[dx$capitulo == \"Prólogo\"] &lt;- \"002 - Prólogo\"\n\n# Elimina la información que no interesa\ndx &lt;- dx[dx$parte != dx$texto, ]\ndx$roman &lt;- NULL\ndx &lt;- dx[dx$texto != \"\", ]\n\n# Añade un número de párrafo a cada párrafo de\n# cada capítulo. Así que siempre se reinicia en\n# cuenteo a cada nuevo capítulo.\nlibrary(dplyr)\ndx &lt;- dx |&gt;\n    group_by(capitulo) |&gt;\n    mutate(parrafo = row_number())\n\n# Elimina los espacios en blanco al principio y\n# al final del texto\ndx$texto &lt;- trimws(dx$texto)\n\n# Selecciona solo las variables.de interés\ndx &lt;- dx[, c(\"parte\", \"capitulo\", \"parrafo\", \"texto\")]\n\n\n# Visualiza los resultados\nlibrary(reactable)\nreactable(dx, resizable = T, wrap = F)\n\n\n\n\n\n\nEl paso siguiente consiste en crear una versión distinta del mismo texto. Pero ahora, la novela será dividida de forma que cada observación en la base de datos corresponderá a un capítulo completo:\n\n# Genera una base de datos agregada por capítulo\n# (y no por párrafo, como la anterior)\ndc &lt;- aggregate(list(texto = dx$texto), by = list(parte = dx$parte,\n    capitulo = dx$capitulo), FUN = paste, collapse = \"\\n\\n\")\n\n# Visualiza los resultados\nreactable(dc, resizable = T, wrap = F)\n\n\n\n\n\n\nFinalmente, estandarizamos los nombres de las dos bases de datos y, a continuación, las guardamos en un archivo de R que será empleado en los análisis:\n\n# Estandariza los nombres de las\n# bases de datos\nregp &lt;- dx\nregc &lt;- dc\n\n# Guarda los resultados\nsave(regp, regc, file=\"textos/Regenta.RData\")\n\n\n\nCódigo como modelo\nEl código anterior es un modelo que puede ser empleado para el tratamiento de cualquier texto con una estructura semejante a de una novela. Para ello, solo es necesario cambiar la dirección del texto original y ajustar los nombres de las partes y capítulos. Además, es posible modificar el código para que se ajuste a las necesidades de cada texto. Por ejemplo, si el texto original no tiene partes, se puede eliminar la parte de la división en partes. O si el texto no tiene capítulos, se puede eliminar la parte de la división en capítulos.\nNo hay un código único que sea válido para todos los textos. Por ello, es necesario adaptar el código a las características de cada texto. Sin embargo, el código presentado aquí es un buen punto de partida para el tratamiento de cualquier texto con una estructura de partes o capítulos.\nComo ejercicio, se podría intentar aplicar el código a “Don Quijote”, por ejemplo. Su código en el Projecto Gutenberg es 2000."
  }
]