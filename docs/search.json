[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\nCode\n1 + 1\n\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "",
    "text": "La preparación representa el paso previo para convertir los textos en datos. En ese apartado, podrás encontrar cómo se han preparado los textos paso a paso."
  },
  {
    "objectID": "index.html#preparación-de-los-textos",
    "href": "index.html#preparación-de-los-textos",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "",
    "text": "La preparación representa el paso previo para convertir los textos en datos. En ese apartado, podrás encontrar cómo se han preparado los textos paso a paso."
  },
  {
    "objectID": "index.html#la-regenta",
    "href": "index.html#la-regenta",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "La Regenta",
    "text": "La Regenta\nEn el siguiente tópico, aplicamos un conjunto de técnicas de análisis y visualización de datos a la novela “La Regenta” de Leopoldo Alas Clarín.\nanalisis.html"
  },
  {
    "objectID": "index.html#tres-sombreros-de-copa",
    "href": "index.html#tres-sombreros-de-copa",
    "title": "filoRAnálisis de textos literarios con R",
    "section": "Tres sombreros de copa",
    "text": "Tres sombreros de copa\nFinalmente, utilizamos la obra de teatro “Tres sombreros de copa” de Miguel Mihura como fuente para el empleo de técnicas de análisis de redes sociales en R a partir de textos literarios."
  },
  {
    "objectID": "prepa.html",
    "href": "prepa.html",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de datos aplicados a textos. Según las características de cada obra, podemos llevar a cabo un análisis de frecuencia de palabras, de sentimientos, emplear diccionarios (léxicos o glosarios) para identificar ciertos rasgos o atributos. También resulta posible jugar con su estructura, agregando los datos por párrafo, capítulo, personaje o cualquier otra características que lo permita.\nPara el presente curso, hemos seleccionado dos textos literarios: una novela y una obra de teatro. La novela es “La Regenta”, de Leopoldo Alas “Clarín” y la pieza de teatro “Tres sombreros de copa”, de Miguel Mihura. Ambas obras son clásicos de la literatura española y permiten comparar los resultados de los análisis de textos literarios. Además de por su alto valor literario, nos interesan en particular por sus diferencias estructurales y cómo nos permiten realizar distintos tipos de análisis.\nAunque ambas puedan ser objeto de la mayor parte de los análisis que introduciremos aquí, cada una de ellas nos permitirá aplicar distintas técnicas de modo más fructífero. Por ejemplo, en “La Regenta” nos interesará explorar la estructura de los capítulos, los temas que aparecen, sus principales personajes, la frecuencia de palabras y la red de palabras. En el caso de “Tres sombreros de copa”, nos interesará explorar la red de diálogos y medir las diferentes formas de centralidad o influencia de los personajes en la trama."
  },
  {
    "objectID": "prepa.html#introducción",
    "href": "prepa.html#introducción",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de datos aplicados a textos. Según las características de cada obra, podemos llevar a cabo un análisis de frecuencia de palabras, de sentimientos, emplear diccionarios (léxicos o glosarios) para identificar ciertos rasgos o atributos. También resulta posible jugar con su estructura, agregando los datos por párrafo, capítulo, personaje o cualquier otra características que lo permita.\nPara el presente curso, hemos seleccionado dos textos literarios: una novela y una obra de teatro. La novela es “La Regenta”, de Leopoldo Alas “Clarín” y la pieza de teatro “Tres sombreros de copa”, de Miguel Mihura. Ambas obras son clásicos de la literatura española y permiten comparar los resultados de los análisis de textos literarios. Además de por su alto valor literario, nos interesan en particular por sus diferencias estructurales y cómo nos permiten realizar distintos tipos de análisis.\nAunque ambas puedan ser objeto de la mayor parte de los análisis que introduciremos aquí, cada una de ellas nos permitirá aplicar distintas técnicas de modo más fructífero. Por ejemplo, en “La Regenta” nos interesará explorar la estructura de los capítulos, los temas que aparecen, sus principales personajes, la frecuencia de palabras y la red de palabras. En el caso de “Tres sombreros de copa”, nos interesará explorar la red de diálogos y medir las diferentes formas de centralidad o influencia de los personajes en la trama."
  },
  {
    "objectID": "prepa.html#la-regenta-párrafos-y-capítulos",
    "href": "prepa.html#la-regenta-párrafos-y-capítulos",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "“La Regenta”: párrafos y capítulos",
    "text": "“La Regenta”: párrafos y capítulos\n\nEstructura de la base de datos\nLa novela “La Regenta” es una obra de Leopoldo Alas “Clarín” publicada en 1884. Como sabéis, se trata de una de las novelas más importantes de la literatura española y representa uno de los mejores ejemplares de la novela realista/naturalista del siglo XIX. Se conforma por 30 capítulos, divididos en dos tomos de 15 apartados cada uno.\nEl objetivo de esta presente sección consiste en preparar el texto de “La Regenta” para su análisis por medio de herramientas y técnicas estadísticas. De modo concreto, nos interesa organizar el texto en dos bases de datos. La primera organizada por párrafos y la segunda por capítulos. Cada una de ellas permitirá la aplicación de análisis con distinto nivel de detalle.\nLlamaremos aquí “base de datos” una tabla de datos con N filas y N columnas. Cada fila corresponderá a un párrafo o capítulo y cada columna a una variable que nos interese analizar. Tendremos, por lo tanto, dos unidades de agregación y sus correspondientes atributos: parte (título, prólogo o tomo), capítulo, párrafo (en su caso) y texto.\n\n\nMétodo de conversión de texto a datos\nResulta muy sencillo descargar la novela “La Regenta”. Podemos emplear el paquete gutenbergr para descargar el texto directamente en R y trabajar con él. Solo tenemos que añadir un paso más al trabajo: convertir la codificación de caracteres a “latin1” para evitar problemas con las tildes.\n\n\nCode\n# Abre la librería gutenbergr\n# para bajar el texto\nlibrary(gutenbergr)\n\n# Baja el texto de \"La Regenta\"\n# cuyo id es igual 17073\nre &lt;- gutenberg_download(gutenberg_id = 17073, \n                         verbose = FALSE)\n\n# Cambia la codificación de caracteres a\n# a latin1 para evitar problemas con las tildes\nEncoding(re$text) &lt;- \"latin1\"\n\n# Convierte el texto en un solo string\nre &lt;- paste0(re$text, \n             collapse = \"\\n\")\n\n\nCon ese sencillo primer paso, ya tenemos la novela en nuestro ordenador. No obstante, hacen falta algunos tratamientos adicionales para convertir el texto en una base de datos que se pueda emplear en comparaciones, análisis de redes de palabras, etc.\nLa etapa siguiente trata de eliminar los saltos de línea y recuperar la estructura de los párrafos. Para ello, empleamos una expresión regular que nos permita identificar los párrafos y corregir los saltos de línea al final de cada frase.\n\n\nCode\n# Carga el paquete stringi\n# que permite trabajar con expresiones regulares\n# y otras tareas de manipulación\n# de textos\nlibrary(stringi)\n\n# Corrige los párrafos para que no tengan\n# un salto de línea al final de cada frase\nrx &lt;- stri_replace_all_regex(\n            re,\n            \"(\\\\S|\\\\p{L})(\\n)(\\\\S{1}|\\\\p{L})\",\"$1 $3\")\n\n\nPara entender lo que hemos hecho, explicaremos la gramática de la expresión regular empleada:\n\n(\\\\S|\\\\p{L}): busca uno o más caracteres que no sean espacios en blanco (\\S) o (|) una letra con acentuación latina (\\p{L}).\n(\\n): busca un salto de línea.\n(\\\\S{1}|\\\\p{L}): busca un único carácter que no sea un espacio en blanco (\\S{1}) o (|) una letra con acentuación latina (\\p{L}).\n\ny los reemplaza por:\n\n$1 $3: por el primer carácter encontrado ($1), un espacio y el último carácter encontrado ($3).\n\nDe ese modo:\n“El poeta es un fingidor.”\n“Finge tan completamente”\n“que llega a fingir que es dolor”\n“el dolor que de verdad siente.”\nse convierte en:\n“El poeta es un fingidor. Finge tan completamente que llega a fingir que es dolor el dolor que de verdad siente.”\nDe ese modo, el R lo hace para TODOS los párrafos a la vez y nos ahora mucho trabajo de preparación de cualquier texto.\nUna vez corregidos los párrafos, podemos convertir el texto en un vector de líneas para poder trabajar con él.\n\n\nCode\n# Carga el paquete readr, que permite\n# convertir textos en vectores\nlibrary(readr)\n\n# Vuelve a seleccionar los párrafos\nre &lt;- read_lines(rx)\n\n\nEl resultado es un vector de caracteres llamado re con 12.164 elementos. Cada elemento corresponde o bien a un párrafo o bien a un salto de línea indicando la separación entre dos párrafos.\nCon esa información, nos interesa asociar cada párrafo a la estructura formal de la novela. En el caso de “La Regenta”, la novela está dividida en un prólogo, dos tomos y 30 capítulos, siendo los quince primeros pertenecientes al primer tomo y los quince restantes al segundo.\nPara llevar a cabo dicha tarea, debemos identificar los elementos que marcan el inicio de cada parte de la novela. En este caso, el prólogo, los tomos y los capítulos. El prólogo y los tomos son fácilmente identificables por su título. Basta con buscar en qué líneas aparecen las palabras “Prólogo” y “Tomo” para identificarlos.\nLos capítulos, por otra parte, exigen un poco más de trabajo. Se enumeran con números romanos precedidos y seguidos de dos guiones. Por ejemplo, “–I–” indica el punto en el que empieza primer capítulo. “–II–” encuentra el elemento que da inicio al segundo y así sucesivamente. En nuestro ejemplo, el primer capítulo empieza en la línea 59 y el segundo en la 311. Por lo tanto, sabemos que todos los párrafos comprendidos entre 59 y 310 corresponden al primer capítulo. Con esa información en mano, lo que tenemos que hacer es asociar a cada párrafo su correspondiente título, tomo o capítulo.\nEl primer procedimiento consiste en encontrar los índices de las partes y capítulos de la novela y sus descripciones:\n\n\nCode\n# Encuentra los índices del prólogo, de\n# los tomos y los capítulos\npro &lt;- grep(\"Prólogo\",re) # prólogo\ntm &lt;- c(grep(\"Tomo\",re), \n        grep(\"TOMO\",re)) # tomos - índice\ncap &lt;- which(stri_detect_regex(re, \n                            \"^(--)([A-Z]+)(--)$\")==TRUE) # capítulos\n\n# Crea vectores que obtienen\n# los títulos de los tomos y los capítulos\ntx &lt;- re[tm] # tomos - textos\ncx &lt;- re[cap] # capítulos - textos\n\n\nCon los índices, puedo repetir cada nombre de tomo, capítulo, prólogo, etc. en función de cuántos párrafos tenga cada uno. De ese modo, puedo asociar cada párrafo a su correspondiente título, tomo o capítulo:\n\n\nCode\n# Genera un vector que identifica qué líneas\n# pertenecen al título. En la estructura de\n# la novela el prólogo se sigue al título,\n# por eso decimos que se repita la palabra\n# \"Título\" del primer párrafo hasta el\n# inmediatamente anterior al prólogo (pro-1).\nti &lt;- rep(\"Título\", \n          length(1:(pro-1)))\n\n# Hacemos algo parecido con el prólogo. \n# Puesto que antecede al primer tomo,\n# repetimos \"Prólogo\" desde la primera \n# vez que aparece (pro) hasta el párrafo\n# anterior al primer tomo (tm[1]-1).\npro &lt;- rep(\"Prólogo\", \n           length(pro:(tm[1]-1)))\n\n# Para los tomos\n\n# Encuentra el tamaño en párrafos\n# de cada tomo\nlen &lt;- diff(c(tm, length(re)+1))\n\n# Repite la descripción o el nombre\n# de cada tomo para identificar\n# cada párrafo\nta &lt;- sapply(\n        1:(length(tx)), \n          function(i){\n            rep(tx[i], len[i])\n          }, \n      simplify = TRUE)\n\nta &lt;- unlist(ta)\n\n# Para los capítulos\n\n# Encuentra el tamaño en párrafos\n# de cada capítulo\nlen &lt;- diff(c(cap, length(re)+1))\n\n# Repite la descripción o el nombre\n# de cada capítulo para identificar\n# cada párrafo\nca &lt;- sapply(\n  1:(length(cx)), \n  function(i){\n    rep(cx[i], len[i])\n  }, \n  simplify = TRUE)\n\nca &lt;- unlist(ca)\n\n\nFinalmente, empleo todos los vectores generados para crear una base de datos que refleje de modo correcto la parte, el capítulo y el texto de cada párrafo:\n\n\nCode\n# Crea un data frame con los textos, la \n# identificación, de la parte y del capítulo\n\n# Combina los vectores de título,\n# prólogo, tomos en un vetor pt (parte)\npt &lt;- c(ti,pro,ta)\n\n# Añade \"Previa\" para identificar \n# aquellos párrafos que pertenecen \n# al título, prólogo y presentación \n# del primer tomo y combina con los \n# capítulos\ncp &lt;- c(rep(\"Previa\", 58),\n        ca)\n\n# Genera una base de datos con las\n# informaciones completas de\n# identificación de las partes,\n# capítulos y el texto.\ndx &lt;- data.frame(parte = pt, \n                 capitulo= cp, \n                 texto = re)\n\n\nAhora, nos toca transformar la numeración de los capítulos para poder mantener un orden secuencial. Además, nos interesa saber el número del párrafo en cada capítulo, para poder mencionar exactamente dónde se encuentra una referencia exacta en el texto. También queremos eliminar la información que no nos interesa, como los espacios en blanco entre párrafos:\n\n\nCode\n# Elimina los guiones de al identificación de\n# cada capítulo\ndx$capitulo &lt;- gsub(\"--\", \"\", dx$capitulo)\n\n# Convierte los textos de identificación de los\n# capítulos en números romanos y luego los\n# convierte en numérico\ndx$roman &lt;- as.roman(dx$capitulo)\ndx$roman &lt;- as.numeric(dx$roman)\n\n# Asigna los valores numéricos a los capítulos\ndx$capitulo[!is.na(dx$roman)] &lt;- dx$roman[!is.na(dx$roman)]\ndx$capitulo[is.na(dx$roman)] &lt;- dx$parte[is.na(dx$roman)]\n\n# Añade un 0 (cero) para los capítulos menores a\n# 10.\ndx$capitulo[nchar(dx$capitulo) == 1] &lt;- paste0(\"0\",\n    dx$capitulo[nchar(dx$capitulo) == 1])\n\n# Añade 001 y 002 para el título y el prólogo.\n# De ese modo, quedan los primeros una vez se\n# ordene la base de datos.\ndx$capitulo[dx$capitulo == \"Título\"] &lt;- \"001 - Título\"\ndx$capitulo[dx$capitulo == \"Prólogo\"] &lt;- \"002 - Prólogo\"\n\n# Elimina la información que no interesa\ndx &lt;- dx[dx$parte != dx$texto, ]\ndx$roman &lt;- NULL\ndx &lt;- dx[dx$texto != \"\", ]\n\n# Añade un número de párrafo a cada párrafo de\n# cada capítulo. Así que siempre se reinicia en\n# cuenteo a cada nuevo capítulo.\nlibrary(dplyr)\ndx &lt;- dx |&gt;\n    group_by(capitulo) |&gt;\n    mutate(parrafo = row_number())\n\n# Elimina los espacios en blanco al principio y\n# al final del texto\ndx$texto &lt;- trimws(dx$texto)\n\n# Selecciona solo las variables.de interés\ndx &lt;- dx[, c(\"parte\", \"capitulo\", \"parrafo\", \"texto\")]\n\n\n# Visualiza los resultados\nlibrary(reactable)\nreactable(dx, resizable = T, wrap = F)\n\n\n\n\n\n\n\nEl paso siguiente consiste en crear una versión distinta del mismo texto. Pero ahora, la novela será dividida de forma que cada observación en la base de datos corresponderá a un capítulo completo:\n\n\nCode\n# Genera una base de datos agregada por capítulo\n# (y no por párrafo, como la anterior)\ndc &lt;- aggregate(list(texto = dx$texto), by = list(parte = dx$parte,\n    capitulo = dx$capitulo), FUN = paste, collapse = \"\\n\\n\")\n\n# Visualiza los resultados\nreactable(dc, resizable = T, wrap = F)\n\n\n\n\n\n\n\nFinalmente, estandarizamos los nombres de las dos bases de datos y, a continuación, las guardamos en un archivo de R que será empleado en los análisis:\n\n\nCode\n# Estandariza los nombres de las\n# bases de datos\nregp &lt;- dx\nregc &lt;- dc\n\n# Guarda los resultados\nsave(regp, regc, file=\"textos/Regenta.RData\")\n\n\n¿Por qué estandarizamos los nombres? Una de las grandes ventajas de utilizar R se encuentra en su facilidad de manejo de diversas bases de datos de forma simultánea. Por ello, es importante que los nombres de las bases de datos sean fáciles de recordar y de escribir. Además, es importante que los nombres sean descriptivos, para que se pueda recordar fácilmente qué contiene cada base de datos. Cuando trabajemos más tarde con esas bases, sabremos que regp contiene los párrafos de “La Regenta” y que regc contiene los capítulos de “La Regenta”. Haremos algo semejante para la obra teatral.\n\n\nCódigo como modelo\nEl código anterior es un modelo que puede ser empleado para el tratamiento de cualquier texto con una estructura semejante a de una novela. Para ello, solo es necesario cambiar la dirección del texto original y ajustar los nombres de las partes y capítulos. Además, es posible modificar el código para que se ajuste a las necesidades de cada texto. Por ejemplo, si el texto original no tiene partes, se puede eliminar el segmento de código responsable de la división en partes. O si el texto no tiene capítulos, se puede eliminar la sección relativa a la división en capítulos.\nNo hay un código único que sea válido para todos los textos. Por ello, es necesario adaptar el código a las características de cada texto. Sin embargo, el código presentado aquí es un buen punto de partida para el tratamiento de cualquier texto con una estructura de partes o capítulos.\nComo ejercicio, se podría intentar aplicar el código a “Don Quijote”, por ejemplo. Su código en el Projecto Gutenberg es 2000."
  },
  {
    "objectID": "prepa.html#tres-sombreros-de-copa-red-de-diálogos",
    "href": "prepa.html#tres-sombreros-de-copa-red-de-diálogos",
    "title": "PreparaciónPreparación de los textos en R",
    "section": "Tres sombreros de copa: red de diálogos",
    "text": "Tres sombreros de copa: red de diálogos\n\nEstructura de la base de datos\nEn el caso de una obra de teatro, la estructura de la base de datos es diferente. En lugar de tomos y capítulos, tenemos actos y escenas. Además, en lugar de párrafos, tenemos diálogos. Existen marcadores claros que nos permiten identificar cada una de las partes.\nPor su misma estructura, además, las obras de teatro son excelente material para la realización de determinados análisis como el análisis de redes sociales (SNA, en su sigla en inglés). También permiten otros tipos de agregación, como, por ejemplo, por personaje o por acto. De ese modo, es posible analizar las diferencias en términos de lenguaje, vocabulario o temas. Aunque se pueda hacer algo parecido con una novela, el proceso de identificación del diálogo de cada personaje resulta significativamente más laborioso cuando comparado con una pieza teatral.\nEn el caso de la obra de teatro, obtendremos tres bases de datos. La primera contendrá los datos del acto, personaje que habla, personaje a quien destina su habla, el orden del diálogo en la obra y el texto del diálogo.\nLa segunda y tercera base de datos estarán conformadas por una lista de vínculos entre pares de personajes y el número de veces que se comunican de forma dirigida y no dirigida.\nUna red dirigida es aquella en la que se establece una relación de un nodo a otro que puede ser asimétrica. En este caso, la dirección importa. En este caso, el personaje A se dirige al personaje B. El primero es activo y el segundo pasivo y ni siempre existe una correspondencia perfecta o simétrica.\nSin embargo, en una red no dirigida, la relación es recíproca o la dirección indeterminada. No consideramos quién habla con quién, sino la intensidad de su vínculo o el total de veces que han interactuado.\nPensemos en un ejemplo claro extraído de las redes sociales. No es lo mismo seguir a Rosalía o cualquier persona famosa que ser seguido por una de ellas. En una red no dirigida, solo sabemos que existe un vínculo entre dos personas, pero no sabemos quién es el que sigue el otro. En una dirigida, tenemos una información vital que nos permite entender mejor la importancia de cada nodo en la red.\nCada una de esas formas de tratar el vínculo entre los personajes nos ofrece información distinta sobre el rol y la importancia de cada uno de ellos en la obra. Por lo tanto, nos interesa tener ambas redes para analizarlas y compararlas.\nPara ello, emplearemos la obra “Tres sombreros de copa” de Miguel Mihura. Se trata de una pieza en tres actos con 18 personajes. No presenta una estructura compleja, lo que facilita el tratamiento de los datos.\n\n\nDe diálogos a datos\nEl primer paso es leer el texto de la obra. Aquí transformaremos los diálogos en datos que puedan, luego, ser sometidos a análisis. Empezamos por leer el texto de la obra. Para ello, emplearemos la función pdf_text del paquete pdftools. A continuación, eliminaremos los espacios en blanco múltiples entre palabras y las cabeceras.\n\n\nCode\n# Carga los paquetes necesarios para el\n# tratamiento de los textos\nlibrary(pdftools)  # Lee el pdf original de la obra\nlibrary(readr)  # Lee las líneas del texto \nlibrary(stringi)  # Funciones de manipulación de texto\n\n# Lee el pdf de la obra de Mihura\npd &lt;- pdf_text(\"https://www.edu.xunta.gal/centros/cpilorenzobaleiron/system/files/u2/mihura__miguel_-_tres_sombreros_de_copa.pdf\")\n\n# Elimina los espacios en blanco múltiples entre\n# palabras\npx &lt;- read_lines(pd)\npx &lt;- trimws(px)\npx &lt;- gsub(\"\\\\s+\", \" \", px, perl = T)\n\n# Elimina las cabeceras de las páginas y los\n# números de página del PDF\nnn &lt;- which(px %in% c(\"3 sombreros de copa Miguel Mihura\"))\npd &lt;- px[-c(nn - 1, nn)]\n\n# Elimina el número de la última página\npd &lt;- pd[-length(pd)]\n\n# Hace una modificación del texto para facilitar\n# el reconocimiento de uno de los personajes\npd &lt;- stri_replace_all_fixed(pd, \"EL ODIOSO SEÑOR,\",\n    \"\\nEL ODIOSO SEÑOR.\")\n\n\nEn el siguiente paso, toca separar los diálogos de los personajes. Emplearemos una expresión regular que identifica los nombres de los personajes y los separa de los diálogos creando un prefijo “PERSONA-” para identificar más fácilmente qué líneas corresponden al nombre del interlocutor.\nEn la pieza, los nombres de los personajes se identifican por una o varias palabras en mayúsculas que inician la frase seguidas de un punto, un espacio y, luego, son sucedidas por el texto. Por ejemplo, “DIONISIO. No. No veo nada.” o “DON ROSARIO. Parece usted tonto, don Dionisio.” nos informan un patrón claro. El objetivo es cortar el texto en dos partes: una con el nombre del personaje y otra con el diálogo.\n\n\nCode\n# Identifica las líneas que contienen los nombres\n# de los personajes y las separa de los diálogos\npx &lt;- stri_replace_all_regex(pd,\"^([[A-Z|\\\\p{Lu}]+\\\\s{1,1}[A-Z|\\\\p{Lu}]+]+)(\\\\.\\\\s{1,1})\",\"\\n\\nPERSONA-$1$2\\n\\n\") \n\n\nComo en el caso de la novela, empleamos una expresión regular para identificar los nombres y separarlos de los textos.\n\n^ indica que la expresión regular buscará todo que comience una línea con las características a continuación.\n[A-Z|\\\\p{Lu}]+ busca una o más letras en mayúsculas que puedan contener textos con tilde.\n\\\\s{1,1} busca un espacio en blanco.\n[A-Z|\\\\p{Lu}]+ busca una o más letras en mayúsculas que puedan contener textos con tilde.\n\nComo podéis ver, la segunda expresión se repite, pues los nombres, que están en mayúsculas en la edición elegida, pueden estar compuestos por más de una palabra. También vemos que todo ese conjunto se encuentra dentro de un grupo []+ que indica que puede haber una o más repeticiones de ese conjunto, es decir, varias palabras en mayúsculas separadas por un espacio.\nEl segundo grupo de la expresión regular, (\\\\.\\\\s{1,1}), busca un punto seguido seguido de un espacio en blanco.\nAsí que, en resumen, la expresión regular busca una o más palabras en mayúsculas que inicien una línea y estén seguidas de un punto y un espacio en blanco. Este es el patrón que buscamos identificar.\nLa segunda añade dos saltos de línea (\\n\\n) y la fórmula PERSONA- antes de repetir los valores encontrados ($1$2) y, luego, introducir otros dos saltos de línea (\\n\\n) para separar el nombre del personaje del texto del diálogo.\nNuestros ejemplos quedarían así:\nOriginal: “DIONISIO. No. No veo nada.”\nModificado: “\\n\\nPERSONA-DIONISIO.\\n\\nNo. No veo nada.”\nOriginal: “DON ROSARIO. Parece usted tonto, don Dionisio.”\nModificado: “\\n\\nPERSONA-DON ROSARIO.\\n\\nParece usted tonto, don Dionisio.”\nAl ejecutar la función read_lines() justo en seguida, el nombre y el textos quedan separados.\nEn el código abajo realiza justamente dicha tarea y, además, elimina los saltos de línea que se encuentran en medio de los diálogos.\n\n\nCode\n# Elimina los saltos de línea en los diálogos\npx &lt;- read_lines(px)\npd &lt;- paste(px, collapse = \"\\n\")\npx &lt;- stri_replace_all_regex(pd,\"(\\\\S|\\\\p{L})(\\n|\\n\\n)(\\\\S{1}|\\\\p{L})\",\"$1 $3\")\npd &lt;- read_lines(px)\n\n\nCon esto resuelto, obtenemos la descripción y los índices de los actos y personajes. Se emplearán luego para la creación de la base de datos con los diálogos.\n\n\nCode\n# Identifica los actos\nna &lt;- which(stri_detect_regex(pd, \"^ACTO\")==TRUE)\nta &lt;- pd[na]\n\n# Identifica los personajes\nnp &lt;- which(stri_detect_regex(pd, \"^PERSONA-\")==TRUE)\npp &lt;- pd[np]\n\n\nComo en “La Regenta”, se crean variables o vectores que repiten el título del acto y el nombre del personaje para cada diálogo.\n\n\nCode\n# Atribuye una sección inicial de preámbulo\n# para la presentación de personajes y\n# la descripción de la escena inicial\npt &lt;- rep(\"Preambulo\",length(1:(na[1]-1)))\n\n# Para cada acto, se asigna el título del acto\nfor(i in 1:(length(na)-1)){\n  \n  na[i+1]-na[i]  \n\n  pt &lt;- c(pt,rep(ta[i],length((na[i]):(na[i+1]-1))))\n    \n}\n\n# Identifica el último acto\npt &lt;- c(pt, rep(ta[length(na)],length((na[length(na)]):length(pd))))\n\n# Atribuye una sección inicial de introducción\npe &lt;- rep(\"Introducción\",length(1:(np[1]-1)))\n\n# Para cada personaje, se asigna el nombre del personaje\nfor(i in 1:(length(np)-1)){\n  \n  np[i+1]-np[i]  \n  \n  pe &lt;- c(pe,rep(pp[i],length((np[i]):(np[i+1]-1))))\n  \n}\n\npe &lt;- c(pe, rep(pp[length(np)],length((np[length(np)]):length(pd))))\n\n\nCon todas las variables a mano:\n\nlas juntamos en una base de datos;\neliminamos las líneas vacías y;\neliminamos diálogos que contienen el nombre del acto.\n\n\n\nCode\n# Convierte en una base de datos\ndd &lt;- data.frame(pt, pe, pd)\ndd &lt;- dd[dd$pd!=\"\",]\ndd &lt;- dd[dd$pe!=dd$pd,]\n\n\nPara garantizar que podamos regresar en cualquier momento a la secuencia original de los diálogos, creamos una variable que ordene los diálogos en el orden en que aparecen en la obra. No obstante, a veces, existe más de una línea de diálogo por personaje. El orden debe llevar en cuenta esta peculiaridad.\n\n\nCode\n# Define un orden para los\n# diálogos\ndd$ord &lt;- NA\ndd$px &lt;- paste0(dd$pt,\" - \", dd$pe)\n\n# Para cada diálogo\nfor(i in 1:nrow(dd)){\n  \n  # Establece el orden del dialogo\n  # de forma secuencial\n  dd$ord[i] &lt;- i\n  \n  # Si es el segundo diálogo o posterior\n  if(i&gt;1){\n    \n    # Si el personaje es el mismo\n    if(dd$px[i]==dd$px[i-1]){\n      \n      # Mantiene el mismo orden del\n      # personaje anterior\n      dd$ord[i] &lt;- dd$ord[i-1]\n      \n    # Caso contrario\n    }else{\n      # Aumenta el orden del personaje\n      # (orden del anterior más uno)\n      dd$ord[i] &lt;- dd$ord[i-1]+1 \n    }\n  }\n  \n}\n\n\nEstamos casi ya. Ahora, juntamos el texto de un mismo personaje, en el mismo orden dentro de un acto, en un solo diálogo. De esa manera, evitamos múltiples observaciones que, en realidad, dicen respeto a la misma unidad de análisis.\n\n\nCode\n# Fusiona el texto de un mismo personaje \n# en un mismo dialogo\nag &lt;- aggregate(list(dialogo=dd$pd), \n                by=list(acto=dd$pt,\n                        personaje_A=dd$pe,\n                        orden=dd$ord), \n                FUN=paste, \n                collapse=\"\\n\")\n\n\nEl paso final consiste en eliminar la información innecesaria, como retirar el prefijo “PERSONA-” que hemos empleado como ayuda, y visualizar los resultados.\n\n\nCode\n# Elimina información innecesaria\nag$personaje_A[grep(\"ACTO\",ag$dialogo)] &lt;- \"Introducción\"\nag$personaje_A&lt;-gsub(\"PERSONA-\",\"\",ag$personaje_A)\nag$personaje_A&lt;-gsub(\"\\\\.\",\"\",ag$personaje_A)\n\n# Vemos el resultado\nreactable(ag, resizable = T, wrap = F)\n\n\n\n\n\n\n\n\n\nDe datos a redes de diálogos\nPara transformar la base de datos en una red de diálogos, necesitamos identificar los personajes que dialogan entre sí. Para ello, creamos una variable que identifique el personaje que responde al interlocutor anterior. En muchas ocasiones, el diálogo se interrumpe por distintas razones, como la entrada de un nuevo personaje, el cambio de escena o el fin de un acto. En estos casos, no podemos considerar que el diálogo anterior continúa. Por lo tanto, necesitamos identificar estos puntos de corte.\nLa manera más fácil es realizar una lectura rápida de los diálogos para identificar estos puntos. Abajo, creamos en la base de datos una nueva variable llamada “corte” que identifica tales puntos y nos permitirán establecer de forma correcta el sentido del diálogo y sus interlocutores.\n\n\nCode\n# Identifica los puntos de corte en los diálogos\n# que corresponden a transiciones de escena o\n# cuándo sale uno o más personajes y se empieza\n# otro dialogo o se trata de una respuesta al \n# interlocutor anterior que no obtiene respuesta\n# y se pasa a un nuevo diálogo con otro personaje. \n# Por lo tanto, no se puede considerar\n# como una continuación del dialogo anterior.\nnc &lt;- c(2,112,177,208,211,217,268,338,365,372,378, \n        380, 388,399,417,428,439,445, 448,452,463,\n        469,480,494,495,594,599,605,653,661,673,675,\n        745,824,825,834,837,855,864)\n\n# Crea una variable corte con valor cero\n# para todos los diálogos\nag$corte &lt;- 0\n\n# En aquellos diálogos que representan\n# un corte, cambia de cero a uno para\n# establecer el punto de interrupción\nag$corte[nc] &lt;- 1\n\n\nEl siguiente paso resulta crucial. Necesitamos identificar el personaje al que se dirige el diálogo. Para ello, creamos una nueva variable en la base de datos llamada “personaje_B” que identificará dicho interlocutor. En este momento, emplearemos los puntos de interrupción o corte en los diálogos para determinar de forma correcta a quién se destina el habla.\n\n\nCode\n# Crea una variable vacía en la base de\n# datos para almacenar el personaje\n# que será el receptor de la respuesta\nag$personaje_B &lt;- NA\n\n# Para cada diálogo de la pieza\nfor(i in 1:(nrow(ag)-1)){\n  \n  # Si es la introducción del capitulo o de la obra,\n  # se pasa al siguiente diálogo\n  if(ag$personaje_A[i]==\"Introducción\") next\n\n  # Si se trata de un corte o fin de escena\n  # se considera como respuesta al personaje\n  # anterior (si no es la introducción de la escena)\n  if(ag$corte[i]==1){\n    \n    # Si el personaje anterior es la introducción\n    # se pasa al siguiente diálogo\n    if(ag$personaje_A[i-1]==\"Introducción\") next\n    \n    # Atribuye el personaje de destino del diálogo\n    # como en personaje anterior (respuesta final)\n    ag$personaje_B[i] &lt;- ag$personaje_A[i-1]\n    \n  # En caso que no sea un corte de escena  \n  }else{ \n    # El personaje de destino del diálogo\n    # es el inmediatamente posterior\n    ag$personaje_B[i] &lt;- ag$personaje_A[i+1]\n  }\n}\n\n# Hay un pasaje en el que Sagra, Carmela y\n# Trudy se dirigen a Fanny, por eso resulta\n# necesario corregir el personaje de destino\nag$personaje_B[c(339:355,357:365)] &lt;- \"FANNY\"\n\n# La respuesta de Fanny\nag$personaje_B[c(356)] &lt;- \"LAS TRES\"\n\n# Otra corrección puntual\nag$personaje_B[c(825)] &lt;- \"DIONISIO\"\n\n# Elimina los espacios en blanco al \n# final de los nombres de los personajes\nag$personaje_A &lt;- trimws(ag$personaje_A)\nag$personaje_B &lt;- trimws(ag$personaje_B)\n\n\nFinalmente, creamos la red de diálogos. Ya tenemos una variable con el que habla (personaje_A) y con quién dialoga (personaje_B). A continuación, crearemos una variable para contar cuántas veces hablan entre sí cada par de personajes y sumamos todos. El resultado es una red dirigida de diálogos.\n\n\nCode\n# Separa solo los pares de personaje\n# en diálogo\nres &lt;- ag[,c(\"personaje_A\",\"personaje_B\")]\nres &lt;- res[! is.na(res$personaje_B),]\n\n# Crea un contador para saber\n# cuántas veces cada par de personajes\n# ha dialogado\nres$veces &lt;- 1\n\n# Elimina la introducción como personaje\n# de los dos tipos de red\nres &lt;- res[res$personaje_A!=\"Introducción\",]\nres &lt;- res[res$personaje_B!=\"Introducción\",]\n\n# Guarda los resultados en un nuevo\n# objeto para crear una red no\n# direccional\nrea &lt;- res\n\n# Suma las veces en que se repiten\n# los pares de personajes (red dirigida)\nres &lt;- aggregate(list(freq=res$veces),\n                 by=list(personaje_A=res$personaje_A,\n                         personaje_B=res$personaje_B),\n                 FUN=sum)\n\n# ordena en orden decendiente por la frecuencia \n# en que dialogan \nres &lt;- res[order(res$freq, decreasing = T),]\n\n# Vemos el resultado\nreactable(res, resizable = T, wrap = F)\n\n\n\n\n\n\n\nComo podemos observar, la pareja Dionisio-Paula es la que más dialoga en la obra. Viene seguida de las díadas Dionisio-Don Rosario y Paula-El Odioso Señor. Los diálogos entre esos cuatro personajes superan el 60% de todas las interacciones en la pieza. Pero ya nos vamos adelantando con el análisis.\nConcentrémonos ahora en la creación de la red no dirigida. Se trata de la última etapa en la preparación de los datos. Como ya hemos mencionado, también nos interesa saber cuántas veces han dialogado dos personajes sin importar quién es el que inicia la conversación.\n\n\nCode\n# Carga el paquete necesario para lidiar con\n# grafos\nlibrary(igraph)\n\n# Uniformiza los valores duplicados\n# (Dionisio-Paula y Paula-Dionisio, \n# por ejemplo, se convierten todos \n# en Dionisio-Paula)\n\n# 1) Crea un grafo NO DIRECCIONAL a partir de \n# la red de personajes\ng &lt;- graph_from_data_frame(\n            rea[,c(\"personaje_A\",\"personaje_B\")], \n            directed=FALSE)\n\n# 2) Simplifica la estructura para hacer con que\n# todos los valores estén en una sola dirección\n# pero sin remover los repetidos, pues queremos\n# contarlos\ng &lt;- simplify(g, \n              remove.multiple = F, \n              remove.loops = F)\n\n# Convierte la red en una base de datos\nax &lt;- igraph::as_data_frame(g)\n\n# Cuenta cuántas veces se repite cada par\nax$freq &lt;- 1\n\n# Suma las veces en que se repiten\n# los pares de personajes (red no dirigida)\naa &lt;- aggregate(list(freq=ax$freq),\n                by=list(personaje_A=ax$from,\n                        personaje_B=ax$to),\n                FUN=sum)\n\n# Ordena los resultados en orden descendente\naa &lt;- aa[order(aa$freq, decreasing = T),]\n# Vemos los resultados\nreactable(aa, resizable = T, wrap = F)\n\n\n\n\n\n\n\nFinalmente, estandarizamos los nombres de las bases de datos y las guardamos en un archivo de R.\n\n\nCode\n# Estandariza los nombres de las bases \n# de datos\n\n# Tres sombreros de copa - dialogos\ntsc_d &lt;- ag    \n\n# Tres sombreros de copa - red de personajes (no dirigida)\ntsc_rn &lt;- aa   \n\n# Tres sombreros de copa - red de personajes (dirigida)\ntsc_rd &lt;- res  \n\n# Guarda los resultados\nsave(tsc_d, \n     tsc_rd, \n     tsc_rd, \n     file=\"textos/Tres_sombreros_de_copa.RData\")"
  },
  {
    "objectID": "regenta.html",
    "href": "regenta.html",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos.\nDos tipos de texto. De un lado, una novela. De otro, una obra de teatro. Abren la posibilidad de comparar los resultados de los análisis de textos literarios."
  },
  {
    "objectID": "regenta.html#introducción",
    "href": "regenta.html#introducción",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos.\nDos tipos de texto. De un lado, una novela. De otro, una obra de teatro. Abren la posibilidad de comparar los resultados de los análisis de textos literarios."
  },
  {
    "objectID": "regenta.html#análisis-de-la-novela-la-regenta",
    "href": "regenta.html#análisis-de-la-novela-la-regenta",
    "title": "La RegentaAnálisis de la novela en R",
    "section": "Análisis de la novela “La Regenta”",
    "text": "Análisis de la novela “La Regenta”\nAbrimos los datos\n\n\nCode\n# carga los datos de \"La Regenta\"\nload(\"../textos/Regenta.RData\")\n\n\nHacemos un análisis sumario de los capítulos\n\n\nCode\n# carga el paquete quanteda para \n# algunos análisis\nlibrary(quanteda)\n\n# convierte en un documento corpus\ncp &lt;- corpus(regc, text_field = \"texto\")\n\n# define los capítulos como nombre\n# de los documentos\ndocnames(cp) &lt;- regc$capitulo\n\n# muestra estadísticas básicas de\n# cada capítulo\nsummary(cp)\n\n\nCorpus consisting of 32 documents, showing 32 documents:\n\n          Text Types Tokens Sentences   parte      capitulo\n  001 - Título    16     16         1  Título  001 - Título\n 002 - Prólogo  1661   4649       101 Prólogo 002 - Prólogo\n            01  3753  14662       466  Tomo I            01\n            02  2236   8029       298  Tomo I            02\n            03  2194   8395       384  Tomo I            03\n            04  2448   9121       360  Tomo I            04\n            05  3104  13640       542  Tomo I            05\n            06  2312   8171       347  Tomo I            06\n            07  2194   9012       391  Tomo I            07\n            08  3178  13095       581  Tomo I            08\n            09  2832  10992       492  Tomo I            09\n            10  2096   8184       390  Tomo I            10\n            11  3026  13356       529  Tomo I            11\n            12  4169  18985       717  Tomo I            12\n            13  3611  17074       541  Tomo I            13\n            14  1980   8172       345  Tomo I            14\n            15  2869  13484       531  Tomo I            15\n            16  4022  17978       543 Tomo II            16\n            17  2190   9804       332 Tomo II            17\n            18  2793  10446       311 Tomo II            18\n            19  2947  12333       407 Tomo II            19\n            20  3753  16462       626 Tomo II            20\n            21  3681  16554       676 Tomo II            21\n            22  3256  14615       522 Tomo II            22\n            23  2087   8302       308 Tomo II            23\n            24  2031   8248       317 Tomo II            24\n            25  2343  10096       476 Tomo II            25\n            26  2812  12811       534 Tomo II            26\n            27  3122  14099       642 Tomo II            27\n            28  2889  13290       491 Tomo II            28\n            29  3532  18228       716 Tomo II            29\n            30  3724  21083       843 Tomo II            30\n\n\nHacemos un análisis de frecuencia de palabras\n\n\nCode\n# convierte en una matriz de términos\ndtm &lt;- dfm(tokens(cp, remove_punct = TRUE, \n                  remove_numbers = TRUE, \n                  remove_symbols = TRUE), \n           tolower = TRUE)\n\ndtm &lt;- dfm_remove(dtm, c(stopwords(\"es\"),\"si\"))\n\n# muestra las 50 palabras más frecuentes\ntopfeatures(dtm, 50)\n\n\n      don       ana     usted magistral   aquella     aquel    álvaro    víctor \n     1791       897       822       769       761       733       490       489 \n     casa   regenta     señor   vetusta      allí       ser   después      doña \n      482       468       458       455       450       437       417       414 \n    decía       vez     mesía     podía     ahora      bien    fermín       así \n      414       392       373       369       364       353       350       347 \n     ojos       dos       iba   siempre    quería       tan     menos      dijo \n      347       334       333       332       328       327       327       326 \n     vida     mismo    hombre      dios     veces quintanar     mundo     mujer \n      324       320       315       310       307       305       290       286 \n   tiempo     todas      alma       ver     sabía       día   parecía      amor \n      283       282       281       280       279       271       267       267 \n  aquello     decir \n      265       259 \n\n\ndiccionario\n\n\nCode\ndic &lt;- dictionary(\n  list(\n    familia=c(\"padre\", \"madre\", \"hijo\", \"hija\", \"hermano\", \"hermana\"),\n    sociedad=c(\"vetustense\",\"señor\",\"puebl\",\"ciudad\",\"conversa\",\"amig\"),\n    iglesia=c(\"cura\",\"obispo\",\"sacerdo\",\"confesión\",\"religi\",\"canónig\",\"capilla\"),\n    economia=c(\"dinero\",\"deuda\",\"negoci\",\"trabaj\",\"fortuna\",\"rico\",\"rica\"),\n    sentimientos=c(\"culpa\",\"alegr\",\"amor\",\"remordimiento\",\"ridículo\",\"vergüenza\",\"triste\"),\n    misticismo=c(\"Fermín de Pas\",\"Fermín\",\"\\\\bde Pas\\\\b\", \"magistral\", \"espirit\",\"dios\"),\n    adulterio=c(\"Álvaro Mesía\",\"Álvaro\",\"Mesía\",\"Presidente del Casino\", \"marido\", \"placer\", \"pasión\", \"amante\",\"amorío\"),\n    espacio=c(\"casino\",\"catedral\",\"vivero\",\"casa\",\"espolón\",\"teatro\"),\n    tiempo=c(\"otoño\",\"verano\",\"invierno\",\"primavera\",\"semana santa\",\"navidad\")\n  )\n)\n    \nlibrary(tenet)\n    \ntagCorpus(cp, dic, reshape.to = \"sentence\")\n\n\n\n\n\n\n\n\n\nCode\ndicf &lt;- dictionary(\n  list(\n    familia=c(\"padre\", \"madre\", \"hijo\", \"hija\", \"hermano\", \"hermana\"),\n    sociedad=c(\"vetustense\",\"señor\",\"puebl\",\"ciudad\",\"conversa\",\"amig\")\n))\n\n\nplotLexDiv(cp, dicf, title =\"La Regenta\", subtitle = \"Familia e iglesia en la novela\", palette = pal$cat.awtools.spalette.6[1:2])\n\n\n\n\n\n\n\nCode\nxy &lt;- countKeywords(cp, \n                    dic, \n                    rel.freq = F, \n                    quietly = TRUE)\n\n# Elimina los términos no encontrados\nxy &lt;- xy[xy$frequency&gt;0,]\n\nxy$groups &lt;- NULL\n\nforceDirectedTree(xy,value_col = \"frequency\",\n                  palette = pal$cat.awtools.bpalette.16, \n                  max.radius = 50, \n                  height = 500)\n\n\n\n\n\n\nlo mismo se puede ver así:\n\n\nCode\nplotVoronoiTree(data = xy,\n                value_col = \"frequency\")\n\n\n\n\n\n\ndd\n\n\nCode\ndich &lt;- dictionary(\n  list(\n    hombres=\n      list(\n           Alvaro=c(\"Álvaro Mesía\",\n                    \"Álvaro\",\n                    \"Mesía\",\n                    \"presidente del casino\"),\n           Saturnino=c(\"Saturnino Bermúdez\",\n                       \"Saturnino\",\n                       \"Bermúdez\",\n                       \"Saturno\",\n                       \"Saturnillo\"),\n           Fermin=c(\"Magistral\",\n                    \"Provisor\",\n                    \"Fermín\",\n                    \"De Pas\",\n                    \"Fermín de Pas\",\n                    \"Magistral\"),\n           Victor=c(\"Víctor\",\n                    \"Víctor Quintanar\",\n                    \"Quintanar\"),\n           Otros=c(\"Custodio\",\n                   \"Frígilis\",\n                   \"Anacleto\",\n                   \"Carlos\",\n                   \"Orgaz\",\n                   \"Bismark\",\n                   \"Celedonio\",\n                   \"monaguillo\",\n                   \"Pedro\",\n                   \"Palomo\",\n                   \"Cayetano\",\n                   \"Cayetano Ripamilán\",\n                   \"Ripamilán\",\n                   \"Cenceño\",\n                   \"Pompeyo\",\n                   \"Pompeyo Guimarán\",\n                   \"Guimarán\",\n                   \"Paco\",\n                   \"Paquito\",\n                   \"don Santos\")\n           ),\n    mujeres=\n      list(\n        Ana=c(\"Ana\",\n              \"Anita\",\n              \"Regenta\"),\n        Obdulia=c(\"Obdulia\",\n                  \"Obdulia Fandiño\",\n                  \"Fandiño\",\n                  \"Obdulita\"),\n        Otras=c(\"Visitación\",\n                \"Petra\",\n                \"Camila\",\n                \"doña Anuncia\",\n                \"Anuncita\",\n                \"Águeda\",\n                \"doña Paula\",\n                \"marquesa\",\n                \"doña Petronila\")\n    )\n  )\n)\n\n\n\n\nxp &lt;- countKeywords(cp, \n                    dich, \n                    rel.freq = F, \n                    group.var = \"capitulo\",\n                    quietly = TRUE)\n\n# Agrega los resultados por los dos niveles\n# de código del diccionario\nxx &lt;- aggregate(list(frequency=xp$frequency), \n                by=list(groups=xp$groups, \n                        level1=xp$level2), \n                sum, na.rm=T)\n\n# Elimina los términos no encontrados\n# en el corpus\nxx &lt;- xx[xx$frequency&gt;0,]\n\n# Ordena por capítulo\nxx &lt;- xx[order(xx$groups),]\n\nplotSankey(xx, \n           from = \"level1\", \n           to=\"groups\", \n           value = \"frequency\", \n           opacity = 0.05)\n\n\n\n\n\n\ndddd\n\n\nCode\n# Reorganiza el corpus según\n# sentencias o frases\ncs &lt;- corpus_reshape(cp, \"sentences\")\n\n# Calcula la frecuencia en la\n# que dos codigos del mismo \n# diccionario aparecen juntos\n# en cada frase\nd1 &lt;- matchCodes(cs, \n                dic, \n                level = 1, \n                quietly=TRUE)\n\n# Ordena los resultados de mayor a menor\nd1 &lt;- d1[order(d1$value, decreasing = T),]\n\n\nplotChord(d1, \n          from = \"term1\", \n          to =\"term2\", \n          value= \"value\")\n\n\n\n\n\n\nAhora con los personajes\n\n\nCode\n# Reorganiza el corpus según\n# sentencias o frases\ncs &lt;- corpus_reshape(cp, \"sentences\")\n\n# Calcula la frecuencia en la\n# que dos codigos del mismo \n# diccionario aparecen juntos\n# en cada frase\nd1 &lt;- matchCodes(cs, \n                dich, \n                level = 2, \n                quietly=TRUE)\n\n# Ordena los resultados de mayor a menor\nd1 &lt;- d1[order(d1$value, decreasing = T),]\n\n\nplotChord(d1, \n          from = \"term1\", \n          to =\"term2\", \n          value= \"value\", elementId = \"chord2\")\n\n\n\n\n\n\naaa"
  },
  {
    "objectID": "sombreros.html",
    "href": "sombreros.html",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos."
  },
  {
    "objectID": "sombreros.html#introducción",
    "href": "sombreros.html#introducción",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "",
    "text": "El R permite diferentes tipos de análisis de textos."
  },
  {
    "objectID": "sombreros.html#redes-de-diálogo-en-tres-sombreros-de-copa",
    "href": "sombreros.html#redes-de-diálogo-en-tres-sombreros-de-copa",
    "title": "Tres sombreros de copaAnálisis de redes de diálogo en R",
    "section": "Redes de diálogo en “Tres sombreros de copa”",
    "text": "Redes de diálogo en “Tres sombreros de copa”\nAbrimos los datos\n\n\nCode\n# carga los datos de \"La Regenta\"\nload(\"../textos/Regenta.RData\")\n\n\nHacemos un análisis sumario de los capítulos\naaa"
  }
]