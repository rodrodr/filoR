---
title: "<b>Preparación</b><br>Preparación de los textos en R"
---

```{r setup, include=FALSE, message=F, warning=F, error=F}

library(quanteda)
library(stringi)
library(readr)

```



## Introducción

El R permite diferentes tipos de análisis de datos aplicados a textos. Según las características de cada obra, podemos llevar a cabo un análisis de frecuencia de palabras, de sentimientos, emplear diccionarios (o glosarios) para identificar ciertos rasgos o atributos. También resulta posible jugar con su estructura, agregando los datos por párrafo, capítulo, personaje o cualquier otra características que lo permita.

Para el presente curso, hemos seleccionado dos textos literarios: una novela y una obra de teatro. La novela es "La Regenta", de Leopoldo Alas "Clarín". La obra de teatro es "Tres sombreros de copa", de Miguel Mihura. Ambas obras son clásicos de la literatura española y permiten comparar los resultados de los análisis de textos literarios. No obstante, nos interesan en particular por sus diferencias estructurales y cómo nos permiten realizar distintos tipos de análisis.

Aunque ambas puedan ser objeto de la mayor parte de los análisis que introduciremos aquí, cada una de ellas nos permitirá aplicar distintas técnicas de modo más fructífero. Por ejemplo, en "La Regenta" nos interesará explorar la estructura de los capítulos, los temas que aparecen, sus principales personajes, la frecuencia de palabras y la red de palabras. En el caso de "Tres sombreros de copa", nos interesará explorar la red de diálogos y medir las diferentes formas de centralidad o influencia de los personajes en la trama.


## "La Regenta": párrafos y capítulos

### Estructura de la base de datos

La novela "La Regenta" es una obra de Leopoldo Alas "Clarín" publicada en 1884. Es una de las novelas más importantes de la literatura española y, en particular, de la novela realista del siglo XIX. La novela se compone de 30 capítulos, divididos en dos tomos de 15 capítulos cada uno.

El objetivo de este apartado es preparar el texto de "La Regenta" para su análisis empleando herramientas y técnicas estadísticas. De modo concreto, nos interesa organizar el texto en dos bases de datos. La primera organizada por párrafos y la segunda por capítulos. Cada una de ellas permitirá la aplicación de análisis con distinto nivel de detalle.

Llamaremos aquí "base de datos" una tabla de datos con N filas y N columnas. Cada fila corresponderá a un párrafo o capítulo y cada columna a una variable que nos interese analizar. Tendremos, por lo tanto, dos unidades de agregación y sus correspondientes atributos: parte (título, prólogo o tomo), capítulo, párrafo (en su caso) y texto.

### Método de conversión de texto a datos

Resulta muy sencillo descargar la novela "La Regenta". Podemos emplear el paquete **gutenbergr** para descargar el texto directamente en R y trabajar con él. Solo tenemos que añadir un paso más al trabajo, que es convertir la codificación de caracteres a "latin1" para evitar problemas con las tildes.

```{r}

# Abre la librería gutenbergr
# para bajar el texto
library(gutenbergr)

# Baja el texto de "La Regenta"
# cuyo id es igual 17073
re <- gutenberg_download(gutenberg_id = 17073, 
                         verbose = FALSE)

# Cambia la codificación de caracteres a
# a latin1 para evitar problemas con las tildes
Encoding(re$text) <- "latin1"

# Convierte el texto en un solo string
re <- paste0(re$text, 
             collapse = "\n")



```

Con ese sencillo primer paso, ya tenemos la novela en nuestro ordenador. No obstante, hacen falta algunos pasos adicionales para convertir el texto en una base de datos que podamos emplear para hacer comparaciones, análisis de redes de palabras, etc.

El siguiente paso consiste en eliminar los saltos de línea y recuperar la estructura de los párrafos. Para ello, empleamos una expresión regular que nos permita identificar los párrafos y corregir los saltos de línea al final de cada frase.

```{r}

# Carga el paquete stringi
# que permite trabajar con expresiones regulares
# y otras tareas de manipulación
# de textos
library(stringi)

# Corrige los párrafos para que no tengan
# un salto de línea al final de cada frase
rx <- stri_replace_all_regex(
            re,
            "(\\S|\\p{L})(\n)(\\S{1}|\\p{L})","$1 $3")

```

Para entender lo que hemos hecho, explicaremos la gramática de la expresión regular empleada:

- `(\\S|\\p{L})`: busca uno o más caracteres que no sean espacios en blanco (**\\S**) o (**|**) una letra con acentuación latina (**\\p{L}**).

- `(\n)`: busca un salto de línea.

- `(\\S{1}|\\p{L})`: busca un único carácter que no sea un espacio en blanco (**\\S{1}**) o (**|**) una letra con acentuación latina (**\\p{L}**).

y los reemplaza por:

- `$1 $3`: por el primer carácter encontrado (**$1**), un espacio y el último carácter encontrado (**$3**).

De ese modo: 

"El poeta es un fingidor."

"Finge tan completamente"

"que llega a fingir que es dolor"

"el dolor que de verdad siente."


se convierte en:

"El poeta es un fingidor. Finge tan completamente que llega a fingir que es dolor el dolor que de verdad siente."

De ese modo, el R lo hace para TODOS los párrafos a la vez y nos ahora mucho trabajo de preparación de cualquier texto. 

Una vez corregidos los párrafos, podemos convertir el texto en un vector de líneas para poder trabajar con él.

```{r}

# Carga el paquete readr, que permite
# convertir textos en vectores
library(readr)

# Vuelve a seleccionar los párrafos
re <- read_lines(rx)

```

El resultado es un vector de caracteres llamado **re** con 12.164 elementos. Cada elemento corresponde o bien a un párrafo o bien a un salto de línea que marca la separación entre dos párrafos. 

Con esa información, nos interesa asociar cada párrafo a la estructura formal de la novela. En el caso de "La Regenta", la novela está dividida en un prólogo, dos tomos y 30 capítulos, siendo los quince primeros pertenecientes al primer tomo y los quince restantes al segundo.

Para llevar a cabo dicha tarea, debemos identificar los elementos que marcan el inicio de cada parte de la novela. En este caso, el prólogo, los tomos y los capítulos. El prólogo y los tomos son fácilmente identificables por su título. Basta con buscar en qué líneas aparecen las palabras "Prólogo" y "Tomo" para identificarlos.

Los capítulos, por otra parte, exigen un poco más de trabajo. Se enumeran con números romanos precedidos y seguidos de dos guiones. Por ejemplo, "--I--" indica el punto en el que empieza primer capítulo. "--II--" encuentra el elemento que da inicio al segundo y así sucesivamente. En nuestro ejemplo, el primer capítulo empieza en la línea 59 y el segundo en la 311. Por lo tanto, sé que todos los párrafos comprendidos entre 59 y 310 corresponden al primer capítulo.
  

```{r}

# Encuentra los índices del prólogo, de
# los tomos y los capítulos
pro <- grep("Prólogo",re) # prólogo
tm <- c(grep("Tomo",re), 
        grep("TOMO",re)) # tomos - índice
cap <- which(stri_detect_regex(re, 
                            "^(--)([A-Z]+)(--)$")==TRUE) # capítulos


# Crea vectores que obtienen
# los títulos de los tomos y los capítulos
tx <- re[tm] # tomos - textos
cx <- re[cap] # capítulos - textos

```

Con los índices, puedo repetir cada nombre de tomo, capítulo, prólogo, etc. en función de cuántos párrafos tenga cada uno. De ese modo, puedo asociar cada párrafo a su correspondiente título, tomo o capítulo:

```{r}

# Genera un vector que identifica qué líneas
# pertenecen al título y al prólogo
ti <- rep("Título", 
          length(1:(pro-1)))

pro <- rep("Prólogo", 
           length(pro:(tm[1]-1)))

# Genera el vector ta que identifica qué líneas
# pertenecen a cada tomo
ta <- vector()

for(i in 1:(length(tm)-1)){
  
  ta <- c(ta, 
          rep(tx[i], 
              length((tm[i]):(tm[i+1]-1))))
  
}

ta <- c(ta, 
        rep(tx[length(tx)],
            length((tm[length(tm)]):length(re))))


# Genera el vector ca que identifica qué líneas
# pertenecen a cada capítulo
ca <- vector()

for(i in 1:(length(cap)-1)){
  
  ca <- c(ca, 
          rep(cx[i], 
              length((cap[i]):(cap[i+1]-1))))
  
}

ca <- c(ca, 
        rep(cx[length(cx)], 
            length((cap[length(cap)]):length(re))))

```

Finalmente, empleo todos los vectores generados para crear una base de datos que refleje de modo correcto la parte, el capítulo y el texto de cada párrafo:

```{r}

# Crea un data frame con los textos, la 
# identificación, de la parte y del capítulo
pt <- c(ti,pro,ta)
cp <- c(rep("Previa", 58),
        ca)
dx <- data.frame(parte = pt, 
                 capitulo= cp, 
                 texto = re)

```


Ahora, nos toca transformar la numeración de los capítulos para poder mantener un orden secuencial. Además, nos interesa saber el número del párrafo en cada capítulo, para poder mencionar exactamente dónde se encuentra una referencia exacta en el texto. También queremos eliminar la información que no nos interesa, como los espacios en blanco entre párrafos:

```{r warning=FALSE, error=F, message=FALSE}
#| tidy: true
#| tidy.opts: { width.cutoff: 50 }


# Elimina los guiones de al identificación
# de cada capítulo
dx$capitulo <- gsub("--","",dx$capitulo)

# Convierte los textos de identificación
# de los capítulos en números romanos
# y luego los convierte en numérico
dx$roman <- as.roman(dx$capitulo)
dx$roman <- as.numeric(dx$roman)

# Asigna los valores numéricos a los capítulos
dx$capitulo[! is.na(dx$roman)] <- dx$roman[! is.na(dx$roman)]
dx$capitulo[is.na(dx$roman)] <- dx$parte[ is.na(dx$roman)]

# Añade un 0 (cero) para los capítulos menores
# a 10.
dx$capitulo[nchar(dx$capitulo)==1] <- paste0("0",dx$capitulo[nchar(dx$capitulo)==1])

# Añade 001 y 002 para el título y el prólogo.
# De ese modo, quedan los primeros una vez se
# ordene la base de datos.
dx$capitulo[dx$capitulo=="Título"] <- "001 - Título"
dx$capitulo[dx$capitulo=="Prólogo"] <- "002 - Prólogo"

# Elimina la información que no interesa
dx <- dx[dx$parte!=dx$texto,]
dx$roman <- NULL
dx <- dx[dx$texto!="",]

# Añade un número de párrafo a cada párrafo 
# de cada capítulo. Así que siempre se reinicia
# en cuenteo a cada nuevo capítulo.
library(dplyr)
dx <- dx |> 
  group_by(capitulo) |> 
  mutate(parrafo = row_number())

# Elimina los espacios en blanco al principio y
# al final del texto
dx$texto <- trimws(dx$texto)

# Selecciona solo las variables.de interés
dx <- dx[,c("parte",
            "capitulo",
            "parrafo",
            "texto")]


# Visualiza los resultados
library(reactable)
reactable(dx, 
          resizable = T, 
          wrap = F)

```


El paso siguiente consiste en crear una versión distinta del mismo texto. Pero ahora, la novela será dividida de forma que cada observación en la base de datos corresponderá a un capítulo completo:

```{r warning=FALSE, error=FALSE, message=FALSE}
#| tidy: true
#| tidy.opts: { width.cutoff: 50 }

# Genera una base de datos agregada
# por capítulo (y no por párrafo, como
# la anterior)
dc <- aggregate(
          list(texto=dx$texto), 
          by=list(parte=dx$parte,
                  capitulo=dx$capitulo), 
          FUN=paste, 
              collapse="\n\n")

# Visualiza los resultados
reactable(dc, 
          resizable = T, 
          wrap = F)

```

Finalmente, estandarizamos los nombres de las dos bases de datos y, a continuación, las guardamos en un archivo de R que será empleado en los análisis:

```{r warning=FALSE, error=FALSE, message=FALSE, eval=F}

# Estandariza los nombres de las
# bases de datos
regp <- dx
regc <- dc

# Guarda los resultados
save(regp, regc, file="textos/Regenta.RData")

```


### Código como modelo

El código anterior es un modelo que puede ser empleado para el tratamiento de cualquier texto con una estructura semejante a de una novela. Para ello, solo es necesario cambiar la dirección del texto original y ajustar los nombres de las partes y capítulos. Además, es posible modificar el código para que se ajuste a las necesidades de cada texto. Por ejemplo, si el texto original no tiene partes, se puede eliminar la parte de la división en partes. O si el texto no tiene capítulos, se puede eliminar la parte de la división en capítulos.

No hay un código único que sea válido para todos los textos. Por ello, es necesario adaptar el código a las características de cada texto. Sin embargo, el código presentado aquí es un buen punto de partida para el tratamiento de cualquier texto con una estructura de partes o capítulos.

Como ejercicio, se podría intentar aplicar el código a "Don Quijote", por ejemplo. Su código en el Projecto Gutenberg es 2000. 


## Obra de teatro

### Estructura de la base de datos

En el caso de una obra de teatro, la estructura de la base de datos es diferente. En lugar de partes y capítulos, tenemos actos y escenas. Además, en lugar de párrafos, tenemos diálogos. Existen marcadores claros que nos permiten identificar cada una de las partes. 

Por su misma estructura, además, las obras de teatro son excelente material para la realización de determinados análisis como el análisis de redes sociales (SNA, en su sigla en inglés). También permiten otros tipos de agregación, como, por ejemplo, por personaje o por acto. De ese modo, es posible analizar las diferencias en términos de lenguaje, vocabulario o temas. Aunque se pueda hacer algo parecido con una novela, el proceso de identificación del diálogo de cada personaje resulta significativamente más laborioso cuando comparado con una pieza teatral.

Como en el caso de la novela, obtendremos dos bases de datos. La primera contendrá los datos del acto, personaje que habla, personaje a quien destina su habla, el orden del diálogo en la obra y el texto del diálogo. 

La segunda base de datos estará conformada por una lista de vínculos entre pares de personajes y el número de veces que se comunican. A partir de ese dato, podemos crear diferentes análisis y visualizaciones de la red, así como medir la importancia relativa de cada personaje en la obra.

Para ello, emplearemos la obra "Tres sombreros de copa" de Miguel Mihura. Se trata de una pieza en tres actos con 18 personajes. No presenta una estructura compleja, lo que facilita el tratamiento de los datos.

### De diálogos a datos

La obra de Mihura ...

```{r message=F, warning=F, error=F}
#| tidy: true
#| tidy.opts: { width.cutoff: 50 }

# Carga los paquetes necesarios
# para el tratamiento de los textos
library(pdftools)   # Lee el pdf original de la obra
library(readr)      # Lee las líneas del texto 
library(stringi)    # Funciones de manipulación de texto

# Lee el pdf de la obra de Mihura
pd <- pdf_text("https://www.edu.xunta.gal/centros/cpilorenzobaleiron/system/files/u2/mihura__miguel_-_tres_sombreros_de_copa.pdf")



# Elimina los espacios en blanco múltiples entre
# palabras
px <- read_lines(pd)
px <- trimws(px)
px <- gsub("\\s+"," ", px, perl = T)

# Elimina las cabeceras de las páginas y los
# números de página del PDF 
nn <- which(px%in%c("3 sombreros de copa Miguel Mihura"))
pd <- px[-c(nn-1,nn)]

# Elimina el número de la última página
pd <- pd[-length(pd)]

```



